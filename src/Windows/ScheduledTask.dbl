;;*****************************************************************************
;;
;; Title:       ScheduledTask.dbl
;;
;; Type:        Class
;;
;; Description: Implements a simple API to allow Traditional Synergy applications
;;              to be run as Windows Scheduled tasks.
;;
;; Date:        23rd September 2014
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2014, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import System.Collections

namespace SynPSG.Windows

	public enum TaskSchedule
		None
		Minute
		Hourly
		Daily
		Weekly
		Monthly
		Once
		OnStart
		OnLogon
		OnIdle
		OnEvent
	endenum
	
	public class ScheduledTask
		
		public method ScheduledTask
			required in aTaskName,	String
			required in aTaskDbr,	String
		proc
			;;Store constructor parameters
			TaskName = aTaskName
			TaskDbr = aTaskDbr
			;;Set default values
			RunTaskAsUser = "SYSTEM"
		endmethod
		
		private mTaskName, String
		
		public property TaskName, String
			method get
			proc
				mreturn mTaskName
			endmethod
			method set
			proc
				mTaskName = value
			endmethod
		endproperty
		
		private mTaskDbr, String

		public property TaskDbr, String
			method get
			proc
				mreturn mTaskDbr
			endmethod
			method set
			proc
				mTaskDbr = value
			endmethod
		endproperty

		private mSystem, String

		public property System, String
			method get
			proc
				mreturn mSystem
			endmethod
			method set
			proc
				mSystem = value
			endmethod
		endproperty

		private mRunAsUser, String

		public property RunAsUser, String
			method get
			proc
				mreturn mRunAsUser
			endmethod
			method set
			proc
				mRunAsUser = value
			endmethod
		endproperty

		private mRunAsPassword, String

		public property RunAsPassword, String
			method get
			proc
				mreturn mRunAsPassword
			endmethod
			method set
			proc
				mRunAsPassword = value
			endmethod
		endproperty

		private mRunTaskAsUser, String

		public property RunTaskAsUser, String
			method get
			proc
				mreturn mRunTaskAsUser
			endmethod
			method set
			proc
				mRunTaskAsUser = value
			endmethod
		endproperty

		private mRunTaskAsPassword, String

		public property RunTaskAsPassword, String
			method get
			proc
				mreturn mRunTaskAsPassword
			endmethod
			method set
			proc
				mRunTaskAsPassword = value
			endmethod
		endproperty
		
		public method Create, boolean
			required in  schedule		,TaskSchedule
			required out errorMessage	,String
			endparams
		proc
			mreturn Create(schedule,0,^null,errorMessage)
		endmethod

		public method Create, boolean
			required in  schedule		,TaskSchedule
			required in  modifier		,int
			required out errorMessage	,String
			endparams
		proc
			mreturn Create(schedule,modifier,^null,errorMessage)
		endmethod
		
		public method Create, boolean
			required in  schedule		,TaskSchedule
			required in  modifier		,int
			required in  startTime		,String
			required out errorMessage	,String
			endparams
			record 
				ch, i4
				command, String
				message, a256
				lastmessage, string
			endrecord
		proc
			command = '|schtasks /create /f'

			using schedule select
			(TaskSchedule.None),
				nop
			(TaskSchedule.Minute),
			begin
				command += ' /sc MINUTE'
				if (modifier && modifier >= 1 && modifier <= 1439) then
					command += ' /mo '+%string(modifier)
				else if (modifier)
				begin
					errorMessage = 'Modifier value ' + %string(modifier) + ' is not valid for schedule type MINUTE'
					mreturn false
				end
			end
			(TaskSchedule.Hourly),
			begin
				command += ' /sc HOURLY'
				if (modifier && modifier >= 1 && modifier <= 23) then
					command += ' /mo '+%string(modifier)
				else if (modifier)
				begin
					errorMessage = 'Modifier value ' + %string(modifier) + ' is not valid for schedule type HOURLY'
					mreturn false
				end
			end
			(TaskSchedule.Daily),
			begin
				command += ' /sc DAILY'
				if (modifier && modifier >= 1 && modifier <= 365) then
					command += ' /mo '+%string(modifier)
				else if (modifier)
				begin
					errorMessage = 'Modifier value ' + %string(modifier) + ' is not valid for schedule type DAILY'
					mreturn false
				end
				if ((startTime!=^null)&&(startTime.Length>0))
					command += ' /st ' + startTime
			end
			(TaskSchedule.Weekly),
			begin
				command += ' /sc WEEKLY'
				if (modifier && modifier >= 1 && modifier <= 365) then
					command += ' /mo '+%string(modifier)
				else if (modifier)
				begin
					errorMessage = 'Modifier value ' + %string(modifier) + ' is not valid for schedule type DAILY'
					mreturn false
				end
				if ((startTime!=^null)&&(startTime.Length>0))
					command += ' /st ' + startTime
			end
			(TaskSchedule.Monthly),
			begin
				command += ' /sc MONTHLY'
				if (modifier && modifier >= 1 && modifier <= 12) then
					command += ' /mo '+%string(modifier)
				else if (modifier)
				begin
					errorMessage = 'Modifier value ' + %string(modifier) + ' is not valid for schedule type MONTHLY'
					mreturn false
				end
				if ((startTime!=^null)&&(startTime.Length>0))
					command += ' /st ' + startTime
			end
			(TaskSchedule.Once),
			begin
				command += ' /sc ONCE'
				if ((startTime!=^null)&&(startTime.Length>0))
					command += ' /st ' + startTime
			end
			(TaskSchedule.OnStart),
			begin
				command += ' /sc ONSTART'
			end
			(TaskSchedule.OnLogon),
			begin
				command += ' /sc ONLOGON'
			end
			(TaskSchedule.OnIdle),
			begin
				command += ' /sc ONIDLE'
			end
			(TaskSchedule.OnEvent),
			begin
				errorMessage = 'Schedule type ONEVENT is sot supported yet'
				mreturn false
			end
			endusing

			command += getTaskAndAuthInfo()
			command += ' /ru ' + RunTaskAsUser
			if (RunTaskAsPassword!=^null)
				command += ' /rp ' + RunTaskAsPassword
			command += ' /tr "C:\Program Files (x86)\Synergex\SynergyDE\dbl\bin\dbs.exe ' + TaskDbr + '"'

			open(ch=0,i,command)
			repeat
			begin
				reads(ch,message,eof)
				lastmessage = %atrim(message)
			end
		eof,
			close ch
			
			if (lastmessage!='SUCCESS: The scheduled task "' + TaskName + '" has successfully been created.')
			begin
				errorMessage = lastmessage
				mreturn false
			end
				
			mreturn true
			
		endmethod
		
		public method Run, boolean
			required out errorMessage, String
			endparams
			record 
				ok, boolean
				ch, i4
				command, string
				message, a256
			endrecord
		proc
			ok = true
			errorMessage = ""

			command = "|schtasks /run /i"
			command += getTaskAndAuthInfo()

			open(ch=0,i,command)
			reads(ch,message)
			close ch

			if (message!='SUCCESS: Attempted to run the scheduled task "' + taskName.Trim() + '".')
			begin
				errorMessage = %atrim(message)
				mreturn false
			end
			
			mreturn ok
			
		endmethod

		public method Stop, boolean
			required out errorMessage, String
			endparams
			record 
				ok, boolean
				ch, i4
				command, string
				message, a256
			endrecord
		proc
			ok = true
			errorMessage = ""

			command = "|schtasks /end"
			command += getTaskAndAuthInfo()

			open(ch=0,i,command)
			reads(ch,message)
			close ch

			if (message!='SUCCESS: The scheduled task "' + taskName.Trim() + '" has been terminated successfully.')
			begin
				errorMessage = %atrim(message)
				mreturn false
			end

			mreturn ok
			
		endmethod
		
		public method Delete, boolean
			required out errorMessage, String
			endparams
			record 
				ok, boolean
				ch, i4
				command, string
				message, a256
			endrecord
		proc
			ok = true
			errorMessage = ""

			command = "|schtasks /delete /f"
			command += getTaskAndAuthInfo()

			open(ch=0,i,command)
			reads(ch,message)
			close ch

			if (message!='SUCCESS: The scheduled task "' + taskName.Trim() + '" was successfully deleted.')
			begin
				errorMessage = %atrim(message)
				mreturn false
			end

			mreturn ok

		endmethod
		
		public method GetStatus, String
			endparams
			record 
				ch, int
				command, string
				message, a256
				returnMsg, string
			endrecord
		proc
			command = '|schtasks /query /tn "' + TaskName + '"'
			open(ch=0,i,command)
			repeat
			begin
				reads(ch,message,eof)
				returnMsg = %atrim(message)
			end
		eof,
			close ch
			mreturn returnMsg
		endmethod
		
		private method getTaskAndAuthInfo, string
			endparams
			record 
				authInfo, String
			endrecord
		proc
			authInfo = ' /tn "' + TaskName + '"'
			if (System != ^null)
				authInfo += ' /s ' + System
			if (RunAsUser != ^null)
				authInfo += ' /u ' + runAsUser
			if (RunAsPassword != ^null)
				authInfo += ' /p ' + RunAsPassword
			mreturn authInfo
		endmethod
		
		;;; <summary>
		;;; Get all tasks for a specific system
		;;; </summary>
		;;; <param name="system">System to get tasks for</param>
		;;; <returns></returns>
		public static method GetTasks, @ArrayList
			required in system, string
			required in status, TaskStatus
			endparams
			record 
				ch, int
				command, string
				dataline, a256
				linekey, string
				linevalue, string
				currentFolder, string
				tsk, @TaskInfo
				tasks, @ArrayList
			endrecord
		proc
			;;Define the command to execute
			command = '|schtasks /query /v /fo list'
			if ((system != ^null) && (system.Length > 0))
				command += " /s " + system
			
			;;Create the returned collection
			tasks = new ArrayList()
			currentFolder = ""

			;;Execute the command
			open(ch=0,i,command)
			
			;;Read the resulting data
			repeat
			begin
				reads(ch,dataline,eof)

				if (!dataline) then
				begin
					;;Add the previous task to the returned collection
					if (tsk!=^null && ((tsk.TaskName!=^null)&&(tsk.TaskName.Length>0)))
						call addTask
					;;Start recording a new task
					tsk = new TaskInfo()
					tsk.Folder = currentFolder
				end
				else if (dataline.eq."Folder: ") then
				begin
					currentFolder = %atrim(dataline(9,^size(dataline)))
					tsk.Folder = currentFolder
				end
				else if (dataline.eq."INFO: ") then
				begin
					nop
				end
				else
				begin
					linekey = %atrim(dataline(1:38))
					linevalue = %atrim( dataline(39,^size(dataline))   )
					
					;;Extract the data
					using linekey select
					("HostName:"),
						tsk.HostName = linevalue
					("TaskName:"),
						tsk.TaskName = linevalue
					("Next Run Time:"),
						tsk.NextRunTime = stringToDateAndTime(linevalue)
					("Status:"),
					begin
						using linevalue select
						("Disabled"),
							tsk.Status = TaskStatus.Disabled
						("Ready"),
							tsk.Status = TaskStatus.Ready
						("Running"),
							tsk.Status = TaskStatus.Running
						("Queued"),
							tsk.Status = TaskStatus.Queued
						(),
							throw new ApplicationException("Unrecognized TaskStatus " + linevalue )
						endusing
					end
					("Logon Mode:"),
					begin
						using linevalue select
						("Interactive only"),
							tsk.LogonMode = TaskLogonMode.InteractiveOnly
						("Interactive/Background"),
							tsk.LogonMode = TaskLogonMode.InteractiveOrBackground
						(""),
							throw new ApplicationException("Unrecognized TaskLogonMode " + linevalue )
						endusing
					end
					("Last Run Time:"),
						tsk.LastRunTime = stringToDateAndTime(linevalue)
					("Last Result:"),
						tsk.LastResult = %integer(linevalue,4)
					("Author:"),
						tsk.Author = linevalue
					("Task To Run:"),
						tsk.TaskToRun = linevalue
					("Start In:"),
						tsk.StartIn = linevalue
					("Comment:"),
						tsk.Comment = linevalue
					("Scheduled Task State:"),
					begin
						using linevalue select
						("Enabled"),
							tsk.State = TaskState.Enabled
						("Disabled"),
							tsk.State = TaskState.Disabled
						(""),
							throw new ApplicationException("Unrecognized TaskState " + linevalue )
						endusing
					end
					("Idle Time:"),
						tsk.IdleTime = linevalue
					("Power Management:"),
					begin
						using ((a)linevalue) select
						("No Start On Batteries"),
							tsk.PowerManagement = TaskPowerMode.NoStartOnBattery
						("Stop On Battery Mode "),
							tsk.PowerManagement = TaskPowerMode.StopOnBattery
						("Stop On Battery Mode, No Start On Batteries"),
							tsk.PowerManagement = TaskPowerMode.StopOnBatteryNoStartOnBattery
						(""),
							tsk.PowerManagement = TaskPowerMode.None
						(),
							throw new ApplicationException("Unrecognized TaskPowerMode " + linevalue )
						endusing
					end
					("Run As User:"),
						tsk.RunAsUser = linevalue
					("Delete Task If Not Rescheduled:"),
						tsk.DeleteIfNotRescheduled = linevalue
					("Stop Task If Runs X Hours and X Mins:"),
						tsk.StopIfRunsTooLong = linevalue
					("Schedule:"),
						tsk.Schedule = linevalue
					("Schedule Type:"),
						tsk.ScheduleType = linevalue
					("Start Time:"),
						tsk.StartTime = linevalue
					("Start Date:"),
						tsk.StartDate = linevalue
					("End Date:"),
						tsk.EndDate = linevalue
					("Days:"),
						tsk.Days = linevalue
					("Months:"),
						tsk.Months = linevalue
					("Repeat: Every:"),
						tsk.RepeatEvery = linevalue
					("Repeat: Until: Time:"),
						tsk.RepeatUntilTime = linevalue
					("Repeat: Until: Duration:"),
						tsk.RepeatUntilDuration = linevalue
					("Repeat: Stop If Still Running:"),
						tsk.RepeatStopIfStillRunning = linevalue
					endusing
				end
			end
		eof,
			;;Add the final task to the collection
			call addTask
			close ch
			mreturn tasks
			
		addTask,

			if ((status != TaskStatus.All) && (tsk.Status != status))
				return

			tasks.Add(tsk)

			return			

		endmethod
		
		private static method stringToDateAndTime, string
			required in stringDateTime, a
			endparams
			record 
				pos1,			int
				pos2,			int
				group outDate,	a
					year, 		a4
					month, 		a2
					day, 		a2
					hour,		a2
					min,		a2
					sec,		a2
				endgroup
			endrecord
		proc
			if (!stringDateTime || stringDateTime=="N/A")
				mreturn ""
			
			;1/1/2013 4:51:20 PM
			;10/19/2013 4:51:20 PM
			pos1  = %instr(1,stringDateTime,"/")
			month = %string( ^d(stringDateTime(1:pos1-1)),"XX")
			pos2  = %instr(pos1+1,stringDateTime,"/")
			day   = %string(^d(stringDateTime(pos1+1,pos2-1)),"XX")
			pos1  = %instr(pos2+1,stringDateTime," ")
			year  = stringDateTime(pos2+1,pos1-1)
			pos2  = %instr(pos1+1,stringDateTime,":")
			hour  = %string(^d(stringDateTime(pos1+1,pos2-1)),"XX")
			pos1  = %instr(pos2+1,stringDateTime,":")
			min   = %string(^d(stringDateTime(pos2+1,pos1-1)),"XX")
			pos2  = %instr(pos1+1,stringDateTime," ")
			sec   = %string(^d(stringDateTime(pos1+1,pos2-1)),"XX")
			if (stringDateTime(pos2+1:2)=="PM")
				hour = %string(^d(hour)+12,"XX")
			mreturn outDate
		endmethod

	endclass
	
endnamespace
		
;;*****************************************************************************
;;
;; Title:       TaskInfo.dbl
;;
;; Type:        Class
;;
;; Description: Exposes information about a scheduled task.
;;
;; Date:        24th September 2014
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2014, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

namespace SynPSG.Windows
		
	public enum TaskStatus
		All
		Disabled
		Ready
		Running
		Queued
	endenum
		
	public enum TaskLogonMode
		InteractiveOnly
		InteractiveOrBackground
	endenum
		
	public enum TaskState
		Disabled
		Enabled
	endenum
		
	public enum TaskPowerMode	
		None
		NoStartOnBattery
		StopOnBatteryNoStartOnBattery
		StopOnBattery
	endenum
	
	public class TaskInfo
		
		public Folder, string
		
		public HostName, string
		public TaskName, string
		public NextRunTime, string
		public Status, TaskStatus
		public LogonMode, TaskLogonMode
		public LastRunTime, string
		public LastResult, int
		public Author, string
		public TaskToRun, string
		public StartIn, string
		public Comment, string
		public State, TaskState
		public IdleTime, string
		public PowerManagement, TaskPowerMode
		public RunAsUser, string
		public DeleteIfNotRescheduled, string
		public StopIfRunsTooLong, string
		public Schedule, string
		public ScheduleType, string
		public StartTime, string
		public StartDate, string
		public EndDate, string
		public Days, string
		public Months, string
		public RepeatEvery, string
		public RepeatUntilTime, string
		public RepeatUntilDuration, string
		public RepeatStopIfStillRunning, string
		
	endclass

endnamespace
