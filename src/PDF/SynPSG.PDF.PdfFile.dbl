;;*****************************************************************************
;;
;; File:        SynPSG.PDF.PdfFile.dbl
;;
;; Title:       PdfFile
;;
;; Type:        Partial Class (see also SynPSG.PfdFile.Private.dbl)
;;
;; Description: Provides the ability to create a PDF file. This class provides
;;              a more usable wrapper around the underlying functionality that
;;              is defined in the Synergy/DE CodeExchange item named "pdfkit",
;;              which in turn provides a DBL wrapper around the open source
;;              "libHaru" PDF library.
;;
;;              In order to use this class and other related classes you must:
;;
;;              1. Include the "pdfkit" source code in the same library as this
;;                 class by including the source file pdfdbl.db in your build.
;;
;;              2. Deploy the libHaru DLL's that are distributed with "pdfkit"
;;                 by copying them to your dbl\bin folder.
;;
;; Date:        19th July 2015
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2015, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import System.Collections
import SynPSG
import HPdf
import system
import synpsg

namespace SynPSG.PDF

    ;;; <summary>
    ;;; Provides the ability to create a PDF file. This class provides a more usable
    ;;; wrapper around the underlying functionality defined in the "pdfkit" item
    ;;; from the Synergy/DE CodeExchange
    ;;; </summary>
    public partial class PdfFile

        private doc,        @HPdfDoc
        private fontNormal, @HPdfFont
        private fontBold,   @HPdfFont
        private fontItalic, @HPdfFont
        private fontBoldItalic, @HPdfFont
        private pg,     @HpdfPage

        private leftOffset, int ;Pixels reserved for requested left margin
        private topOffset,  int ;Pixels reserved for requested top margin
        private rightOffset,    int ;Pixels reserved for requested right margin
        private bottomOffset,   int ;Pixels reserved for requested bottom margin
        private totalRows,  int ;Total number of rows for the entire page

        ;;********************************************************************************
        ;;CONSTRUCTOR

        ;;; <summary>
        ;;; Constructs a new PsfFile object.
        ;;; </summary>
        ;;; <param name="aOrientation">Orientation of pages, portrait or landscape.</param>
        ;;; <param name="aLeftMargin">Establishes a left margin for the pages of the document. The value is specified in inches. If you don't specify a left margin then a default value of 0.16 inches will be used. If you don't want any margin then specify a value of 0.</param>
        ;;; <param name="aTopMargin">Establishes a top margin for the pages of the document. The value is specified in inches. If you don't specify a left margin then a default value of 0.16 inches will be used. If you don't want any margin then specify a value of 0.</param>
        ;;; <param name="aRightMargin">Establishes a right margin for the pages of the document. The value is specified in inches. If you don't specify a left margin then a default value of 0.16 inches will be used. If you don't want any margin then specify a value of 0.</param>
        ;;; <param name="aBottomMargin">Establishes a bottom margin for the pages of the document. The value is specified in inches. If you don't specify a left margin then a default value of 0.16 inches will be used. If you don't want any margin then specify a value of 0.</param>
        ;;; <param name="aHeaderRows">Establishes the number of header rows that are to be allocated on each page of the document. Header rows are displayed below the top margin and above the main body of each page of the document.</param>
        ;;; <param name="aFooterRows">Establishes the number of footer rows that are to be allocated on each page of the document. Footer rows are displayed below main body and above the bottom margin of each page of the document.</param>
        ;;; <param name="aPageBackgroundColor">Establishes a custom page background color and implements that color on the first page. The default page background color is white.</param>
        public method PdfFile
            optional in aOrientation,       PdfOrientation
            optional in aLeftMargin,        float
            optional in aTopMargin,         float
            optional in aRightMargin,       float
            optional in aBottomMargin,      float
            optional in aHeaderRows,        int
            optional in aFooterRows,        int
            optional in aPageBackgroundColor,   PdfColor
        proc
            ;;Set page orientation
            if (^passed(aOrientation)) then
                this.Orientation = aOrientation
            else
                this.Orientation = PdfOrientation.Portrait

            ;;Create a new PDF document
            doc = new HPdfDoc()

            ;;Load the fonts we'll be using
            fontNormal = doc.GetFont("Courier", ^null)
            fontBold = doc.GetFont("Courier-Bold", ^null)
            fontItalic = doc.GetFont("Courier-Oblique", ^null)
            fontBoldItalic = doc.GetFont("Courier-BoldOblique", ^null)

            ;;Start the first page
            pg = doc.AddPage(HPdfPageSizes.HPDF_PAGE_SIZE_LETTER,getHaruPageDirection())

            ;;Get the pixel dimensions of the page
            this.Height = %integer(pg.GetHeight())
            this.Width = %integer(pg.GetWidth())

            ;;Left margin
            if (^passed(aLeftMargin) && (aLeftMargin >= 0)) then
                this.LeftMargin = aLeftMargin
            else
                this.LeftMargin = 0.16

            ;;Top margin
            if (^passed(aTopMargin) && (aTopMargin >= 0)) then
                this.TopMargin = aTopMargin
            else
                this.TopMargin = 0.16

            ;;Right margin
            if (^passed(aRightMargin) && (aRightMargin >= 0)) then
                this.RightMargin = aRightMargin
            else
                this.RightMargin = 0.16

            ;;Bottom margin
            if (^passed(aBottomMargin) && (aBottomMargin>=0)) then
                this.BottomMargin = aBottomMargin
            else
                this.BottomMargin = 0.16

            ;;Start with a "normal" font size
            this.FontSize = 12

            ;;Start a text writer with the current font and size
            pg.StartPageWithFont(fontNormal,fontSizeFloat)

            ;;Make sure that text is drawn as solid letters, not an outline with a seperate fill
            pg.SetTextRenderingMode(HPdfTextRenderingMode.HPDF_FILL)

            ;;Calculate the page dimensions in rows and columns based on the current font
            this.RowHeight = fontSizeFloat
            totalRows = %truncate((this.Height-topOffset-bottomOffset)/this.RowHeight)
            this.ColumnWidth = pg.TextWidth("W")
            this.Columns = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)

            ;;Close off the page for now, not sure if we'll need text or graphics first
            pg.EndText()

            ;;Were header rows requested?
            if (^passed(aHeaderRows) && aHeaderRows)
            begin
                data ix, int
                this.HeaderRows = aHeaderRows
                this.HeaderText = new string[this.HeaderRows]
                for ix from 1 thru this.HeaderRows
                    this.HeaderText[ix] = ""
            end

            ;;Were footer rows requested?
            if (^passed(aFooterRows) && aFooterRows)
            begin
                data ix, int
                this.FooterRows = aFooterRows
                this.FooterText = new string[this.FooterRows]
                for ix from 1 thru this.FooterRows
                    this.FooterText[ix] = ""
            end

            ;;Calculate the number of body rows
            this.Rows = totalRows - this.HeaderRows - this.FooterRows

            ;;Set the default colors to black
            this.StrokeColor = PdfColor.Black
            this.FillColor = PdfColor.Black
            this.PageBackgroundColor = PdfColor.White

            ;;Initialize the auto items collection
            this.AutoItems = new ArrayList()

            ;;If we were given a custom backgound color then save it
            if (^passed(aPageBackgroundColor) && (aPageBackgroundColor != PageBackgroundColor))
            begin
                PageBackgroundColor = aPageBackgroundColor
                ;;And use it for the first page
                setPageBackroundColor()
            end

            ;Set the default creator name
            this.Creator = "Synergex PSG PdfFile Class"

            ;;Make sure the error message property is blank not null
            this.ErrorMessage = ""

        endmethod

        ;;********************************************************************************
        ;;PUBLIC METHODS

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Releases resources used by the PDF document.
        ;;; </summary>
        public method Dispose, void
        proc
            doc.FreeDocAll()
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Initializes the PdfFile for use. You must call initialize before attempting
        ;;; to add any content to the document. The first page is created during initialization.
        ;;; </summary>
        ;;; <param name="aFileLocation">The location where the PDF file should be created. This can either be a path, a logical name followed by a colon.</param>
        ;;; <param name="aPartialFileName">Text to be used as part of the PDF file name.</param>
        ;;; <param name="aMinimumColumns">The minimum number of columns required for the document. An appropriate font size will be determined based on this value.</param>
        ;;; <param name="aMaxFontSize">The maximum font size that you want to be selected. If a larger font is calculated then this font size will be used instead.</param>
        ;;; <param name="aCenterBodyInPage">Should the page be configured for the exact number of columns specified, and the content horizontally centered in the page?</param>
        public method Initialize, boolean
            optional in  aFileLocation, string
            optional in  aPartialFileName,  string
            optional in  aMinimumColumns,   int
            optional in  aMaxFontSize,  int
            optional in  aCenterBodyInPage, boolean
            endparams
            record
                ok,         boolean
                attempts,       int
            endrecord
        proc
            ;;Define the output file location
            if (^passed(aFileLocation) && (aFileLocation.Trim().Length > 0)) then
            begin
                this.FileLocation = expandLogicalInFileSpec(aFileLocation)
                if (this.FileLocation == %char(0)) then
                begin
                    this.ErrorMessage = "Invalid location " + aFileLocation
                    mreturn false
                end
                else
                begin
                    if (!this.FileLocation.Trim().EndsWith("\"))
                        this.FileLocation = this.FileLocation.Trim() + "\"
                end
            end
            else
            begin
                this.FileLocation = expandLogicalInFileSpec("TEMP:")
                if (!this.FileLocation.Trim().EndsWith("\"))
                    this.FileLocation = this.FileLocation.Trim() + "\"
            end

            ;;Make sure the output file location exists
            if (!directoryExists(this.FileLocation))
            begin
                mErrorMessage = "Destination folder " + mFileLocation + " does not exist!"
                mreturn false
            end

            ;;Define the output file name
            attempts = 0
            repeat
            begin
                ;;Construct the file name
                if (^passed(aPartialFileName) && (aPartialFileName.Trim().Length > 0)) then
                    this.FileName = DateTimeTools.GetTempFilePrefix() + " " + aPartialFileName.Trim() + ".pdf"
                else
                    this.FileName = DateTimeTools.GetTempFilePrefix() + ".pdf"

                ;;Make sure the file doesn't already exist
                if (fileExists(this.FileLocation + this.FileName)) then
                begin
                    if ((attempts+=1)>5)
                    begin
                        this.ErrorMessage = "Failed to construct unique output file name!"
                        mreturn false
                    end
                    sleep 0.1
                end
                else
                    exitloop
            end

            ;;Are we going to center the body at the requested with within the
            ;;page by manipulating the left and right margins
            if (^passed(aCenterBodyInPage)) then
                this.CenterBodyInPage = aCenterBodyInPage
            else
                this.CenterBodyInPage = true

            ;;Save the number of requested minimum columns
            if (^passed(aMinimumColumns) && aMinimumColumns) then
                this.RequestedColumns = aMinimumColumns
            else
                this.RequestedColumns = 80

            ok = false

            if (this.Columns < this.RequestedColumns) then
            begin
                ;;Not enough columns, decrease the font size until we get a match
                data newFontSize, int
                for newFontSize from mFontSize-1 thru 6 by -1
                begin
                    FontSize = newFontSize
                    pg.SetFontAndSize(fontNormal,fontSizeFloat)
                    this.ColumnWidth = pg.TextWidth("W")
                    this.Columns = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)
                    if (this.Columns >= this.RequestedColumns)
                    begin
                        ok = true
                        exitloop
                    end
                end
            end
            else if (this.Columns > this.RequestedColumns) then
            begin
                ;;Too many columns, increase the font size until we have gone too far
                data newFontSize, int
                for newFontSize from mFontSize+1 thru 64
                begin
                    FontSize = newFontSize
                    pg.SetFontAndSize(fontNormal,fontSizeFloat)
                    this.ColumnWidth = pg.TextWidth("W")
                    this.Columns = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)
                    if (this.Columns < this.RequestedColumns)
                    begin
                        ;;We went too far so back off to the previous font size
                        FontSize = mFontSize - 1
                        pg.SetFontAndSize(fontNormal,fontSizeFloat)
                        this.ColumnWidth = pg.TextWidth("W")
                        this.Columns = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)
                        ok = true
                        exitloop
                    end
                end
            end
            else if (this.Columns == this.RequestedColumns)
            begin
                ;;Perfect match!
                ok = true
            end

            ;;If we were able to find a font size that provides the width that we need then we can continue
            if (ok) then
            begin
                ;;Were we given a maximum font size?
                if (^passed(aMaxFontSize) && aMaxFontSize)
                begin
                    if (this.FontSize > aMaxFontSize)
                    begin
                        ;;Selected font is bigger than maximum requested. Reduce to the requested size.
                        this.FontSize = aMaxFontSize
                        pg.SetFontAndSize(fontNormal,fontSizeFloat)
                        this.ColumnWidth = pg.TextWidth("W")
                        this.Columns = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)
                    end
                end

                ;;How many rows fit on the page at the selected font size?
                this.RowHeight = fontSizeFloat
                totalRows = %truncate((this.Height-topOffset-bottomOffset)/this.RowHeight)
                this.Rows = totalRows - this.HeaderRows - this.FooterRows

                ;;If the page is wider than requested, should we manipulate the margins so that the
                ;;requested width is centered horizontally within the page?

                if ((this.Columns != this.RequestedColumns) && this.CenterBodyInPage)
                begin
                    data additionalColumns, int, this.Columns - this.RequestedColumns
                    data additionalPixels, int, additionalColumns * this.ColumnWidth

                    ;;Divide the additional space between the left and right margins
                    leftOffset += (additionalPixels / 2.0)
                    rightOffset += (additionalPixels / 2.0)

                    this.LeftMargin = leftOffset / 72.0
                    this.RightMargin = rightOffset / 72.0

                    this.Columns = this.RequestedColumns
                end

                ;;Record where we're at
                this.PageNumber = 1
                this.Row = 1
                this.Column = 1
            end
            else
            begin
                this.ErrorMessage = "Failed to select a font size to produce the requested results!"
                Dispose()
            end

            mreturn ok

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Sets the current position within the current page.
        ;;; </summary>
        ;;; <param name="aRow">Row position, between 1 and Rows.</param>
        ;;; <param name="aColumn">Column position, between 1 and Columns.</param>
        public method SetPosition, void
            required in aRow, int
            required in aColumn, int
        proc
            if (aRow < 1) then
                this.Row = 1
            else if (aRow > this.Rows) then
                this.Row = this.Rows
            else
                this.Row = aRow

            if (aColumn < 1) then
                this.Column = 1
            else if (aColumn > this.Columns) then
                this.Column = this.Columns
            else
                this.Column = aColumn
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Prints text at the current position and sets the curent position to the cell
        ;;; immediately after the displayed text, or to the last cell on the current line
        ;;; if the text extends beyond the page body. If the current row is below the page
        ;;; body then a new page is generated and the text is printed at the beginning of
        ;;; the new page.
        ;;; </summary>
        ;;; <param name="aText">Text to display</param>
        ;;; <param name="aBold">Display the text in a bold font.</param>
        ;;; <param name="aItalic">Display the text in an italic font.</param>
        ;;; <param name="aColor">Display the text in a specific color.</param>
        ;;; <param name="aNewLine">Set current position to column 1 on the next line after printing text.</param>
        ;;; <returns>Returns the new current column position.</returns>
        public method PrintText, int
            required in aText, string
            optional in aBold, boolean
            optional in aItalic, boolean
            optional in aColor, PdfColor
            optional in aNewLine, boolean
        proc
            if (this.Row > this.Rows)
                NewPage()

            selectFont(aBold,aItalic)

            if (^passed(aColor) && (aColor != this.StrokeColor))
                setCustomStrokeColor(aColor)

            if (^passed(aColor) && (aColor != this.FillColor))
                setCustomFillColor(aColor)

            pg.BeginText()
            pg.MoveTextPos(XfromCol(this.Column),Body_YFromRow(this.Row))
            pg.ShowText(aText)
            pg.EndText()

            resetFont(aBold,aItalic)

            if (^passed(aColor) && (aColor != this.StrokeColor))
                resetStrokeColor()

            if (^passed(aColor) && (aColor != this.FillColor))
                resetFillColor()

            if (^passed(aNewLine) && aNewLine) then
            begin
                this.Row = this.Row + 1
                this.Column = 1
            end
            else
            begin
                this.Column = this.Column + aText.Length
                if (this.Column > this.Columns)
                    this.Column = this.Columns
            end

            mreturn this.Column

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Prints text at the current position and sets the curent position to the cell
        ;;; immediately after the displayed text, or to the last cell on the current line
        ;;; if the text extends beyond the page body.
        ;;; </summary>
        ;;; <param name="aRow">Row within the page body to display text at.</param>
        ;;; <param name="aCol">Column within the page body to display text at.</param>
        ;;; <param name="aText">Text to display.</param>
        ;;; <param name="aBold">Display the text in a bold font.</param>
        ;;; <param name="aItalic">Display the text in an italic font.</param>
        ;;; <param name="aColor">Display the text in a specific color.</param>
        ;;; <param name="aNewLine">Set current position to column 1 on the next line after printing text.</param>
        ;;; <returns>Returns the new current column position.</returns>
        public method PrintText, int
            required in aRow, int
            required in aCol, int
            required in aText, string
            optional in aBold, boolean
            optional in aItalic, boolean
            optional in aColor, PdfColor
            optional in aNewLine, boolean
        proc
            selectFont(aBold,aItalic)

            if (^passed(aColor) && (aColor != mFillColor))
            begin
                setCustomStrokeColor(aColor)
                setCustomFillColor(aColor)
            end

            pg.BeginText()
            pg.MoveTextPos(XfromCol(aCol),Body_YFromRow(aRow))
            pg.ShowText(aText)
            pg.EndText()

            resetFont(aBold,aItalic)

            if (^passed(aColor) && (aColor != this.FillColor))
            begin
                resetStrokeColor()
                resetFillColor()
            end

            if (^passed(aNewLine) && aNewLine) then
            begin
                this.Row = aRow + 1
                this.Column = 1
            end
            else
            begin
                this.Row = aRow
                this.Column = aCol + aText.Length
                if (this.Column > this.Columns)
                    this.Column = this.Columns
            end

            mreturn this.Column

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Prints text at the specified column in the current row and sets the curent
        ;;; position to the cell immediately after the displayed text, or to the last cell
        ;;; on the current line if the text extends beyond the page body. If the current row
        ;;; is below the page body then a new page is generated and the text is printed at
        ;;; the specified column in the first row of the new page.
        ;;; </summary>
        ;;; <param name="aCol">Column within the current line to display text at.</param>
        ;;; <param name="aText">Text to display.</param>
        ;;; <param name="aBold">Display the text in a bold font.</param>
        ;;; <param name="aItalic">Display the text in an italic font.</param>
        ;;; <param name="aColor">Display the text in a specific color.</param>
        ;;; <param name="aNewLine">Set current position to column 1 on the next line after printing text.</param>
        ;;; <returns>Returns the new current column number.</returns>
        public method PrintText, int
            required in aCol, int
            required in aText, string
            required in aBold, boolean
            optional in aItalic, boolean
            optional in aColor, PdfColor
            optional in aNewLine, boolean
        proc
            if (this.Row > this.Rows)
                NewPage()

            if (aCol <= mColumns) then
                this.Column = aCol
            else
                this.Column = this.Columns

            selectFont(aBold,aItalic)

            if (^passed(aColor) && (aColor != this.FillColor))
            begin
                setCustomStrokeColor(aColor)
                setCustomFillColor(aColor)
            end

            pg.BeginText()
            pg.MoveTextPos(XfromCol(this.Column),Body_YFromRow(this.Row))
            pg.ShowText(aText)
            pg.EndText()

            resetFont(aBold,aItalic)

            if (^passed(aColor) && (aColor != this.FillColor))
            begin
                resetStrokeColor()
                resetFillColor()
            end

            if (^passed(aNewLine) && aNewLine) then
            begin
                this.Row = this.Row + 1
                this.Column = 1
            end
            else
            begin
                this.Column = this.Column + aText.Length
            end

            mreturn this.Column

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Displays the text defined by a PdfTextRowCol text object.
        ;;; </summary>
        ;;; <param name="aTextObj">PdfTextRowCol object to be displayed.</param>
        ;;; <returns>Returns the new current column position.</returns>
        public method PrintTextRowCol, void
            required in aTextObj, @PdfTextRowCol
        proc
            PrintText(aTextObj.Row,aTextObj.Col,aTextObj.Text,aTextObj.Bold,aTextObj.Italic,aTextObj.Color,aTextObj.NewLine)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Displays the text defined by a PdfTextAbsolute text object.
        ;;; </summary>
        ;;; <param name="aTextObj">PdfTextAbsolute object to be displayed.</param>
        ;;; <returns>Returns the new current column position.</returns>
        public method PrintTextAbsolute, void
            required in aTextObj, @PdfTextAbsolute
        proc
            PrintTextAbsolute(aTextObj.X,aTextObj.Y,aTextObj.Text,aTextObj.Color)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Prints text at the specified absolute position. The current position is NOT
        ;;; affected by this method
        ;;; </summary>
        ;;; <param name="aX">X coordinate to display text at.</param>
        ;;; <param name="aY">Y coordinate to display text at.</param>
        ;;; <param name="aText">Text to display.</param>
        ;;; <param name="aColor">Display the text in a specific color.</param>
        public method PrintTextAbsolute, void
            required in aX, float
            required in aY, float
            required in aText, string
            optional in aColor, PdfColor
        proc
            if (^passed(aColor) && (aColor != mFillColor))
            begin
                setCustomStrokeColor(aColor)
                setCustomFillColor(aColor)
            end

            pg.BeginText()
            pg.MoveTextPos(aX,aY)
            pg.ShowText(aText)
            pg.EndText()

            if (^passed(aColor) && (aColor != this.FillColor))
            begin
                resetStrokeColor()
                resetFillColor()
            end

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Loads a TrueType font and embeds it in the PDF document ready for use.
        ;;; </summary>
        ;;; <param name="aFontFile">Full path to the font file (.ttf)</param>
        ;;; <returns>Returns the name of the font that can be passed to the SelectFont method.</returns>
        public method LoadTrueTypeFont, string
            required in aFontFile, string
            record
                ok, boolean
                fileSpec, string
                fontName, string
            endrecord
        proc
            ok = true
            fontName = ^null

            fileSpec = aFontFile.ToLower()
            if (!fileExists(fileSpec) || !fileSpec.EndsWith(".ttf"))
                ok = false

            if (ok)
                fontName = doc.LoadTTFontFromFile(fileSpec,true)

            mreturn fontName

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Selects the font that will be used for subsequent text operations.
        ;;; </summary>
        ;;; <param name="aFontName">Font name, as returned by LoadTrueTypeFont, or one of the native PDF font names (e.g. Courier)</param>
        ;;; <param name="aFontSize">Point size to use.</param>
        public method SelectFont, void
            required in aFontName, string
            required in aFontSize, int
            record
                fontSize, float
                newFont, @HPdfFont
            endrecord
        proc
            newFont = doc.GetFont(aFontName, ^null)
            pg.SetFontAndSize(newFont,fontSize = aFontSize)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Resets the font to Courier and the size to that calculated during Initialize.
        ;;; Call this method to return to fixed-pitch row/column mode after woking with
        ;;; other (generally variable-pitch) fonts.
        ;;; </summary>
        public method ResetFont, void
        proc
            pg.SetFontAndSize(fontNormal,fontSizeFloat)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a horizontal line from the current position to the end of the
        ;;; current line. By default the line is drawn from and to the center of the
        ;;; start and end cells, unless fullWidth is passed, in which case the line is
        ;;; drawn from the left side of the first cell to the right side of the last cell.
        ;;; The current position set to the beginning of the next line.
        ;;; </summary>
        ;;; <param name="aFullWidth">Draw the line the full width of the cells.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 5.</param>
        ;;; <param name="aColor">Line color.</param>
        ;;; <returns>Returns the new current row number.</returns>
        public method DrawLine,     int
            optional in aFullWidth, boolean
            optional in aWidth, int
            optional in aColor, PdfColor
            record
                penWidth,   float
                start_x,    float
                start_y,    float
                end_x,      float
                end_y,      float
            endrecord
        proc
            if (this.Row > this.Rows)
                NewPage()

            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific color then use it
            if (^passed(aColor) && (aColor != this.StrokeColor))
                setCustomStrokeColor(aColor)

            ;;Calculate the start and end points for a center cell to center cell line
            start_x = XfromCol(this.Column) + (this.ColumnWidth / 2)
            start_y = Body_YfromRow(this.Row) + ((this.RowHeight-penWidth)/2)
            end_x   = XfromCol(this.Columns) + (this.ColumnWidth/ 2)
            end_y   = start_y

            ;;If we're being asked for a full-width line then add back in the partial cell pixels
            if (^passed(aFullWidth) && aFullWidth)
            begin
                start_x -= (this.ColumnWidth / 2)
                end_x += (this.ColumnWidth / 2)
            end

            ;;Draw the line
            pg.MoveTo(start_x,start_y)
            pg.LineTo(end_x,end_y)
            pg.Stroke()

            ;;If we changed the line color then revert back to the default color
            if (^passed(aColor) && (aColor != this.StrokeColor))
                resetStrokeColor()

            ;;Update current position
            this.Row = this.Row + 1
            this.Column = 1

            mreturn this.Row

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a line from the current cell to the end of the current line. By default
        ;;; the line is drawn from and to the center of the start and end cells, unless
        ;;; fullWidth is passed, in which case the line is drawn from the left side of the
        ;;; first cell to the right side of the last cell. The current position is
        ;;; NOT updated by line drawing.
        ;;; </summary>
        ;;; <param name="aFromRow">Origin cell row.</param>
        ;;; <param name="aFromCol">Origin cell column.</param>
        ;;; <param name="aToRow">Destination cell row.</param>
        ;;; <param name="aToCol">Destination cell column.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 2.</param>
        ;;; <param name="aColor">Line color.</param>
        public method DrawLine, void
            required in aFromRow, int
            required in aFromCol, int
            required in aToRow, int
            required in aToCol, int
            optional in aWidth, float
            optional in aColor, PdfColor
            endparams
            record
                penWidth,   float
                start_x,    float
                start_y,    float
                end_x,      float
                end_y,      float
            endrecord
        proc
            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific color then use it
            if (^passed(aColor) && (aColor != this.StrokeColor))
                setCustomStrokeColor(aColor)

            ;;Calculate the start and end points for a center cell to center cell line
            start_x = XfromCol(aFromCol) + (this.ColumnWidth / 2)
            start_y = Body_YfromRow(aFromRow) + ((this.RowHeight-penWidth)/2)
            end_x   = XfromCol(aToCol) + (this.ColumnWidth/ 2)
            end_y   = Body_YfromRow(aToRow) + ((this.RowHeight-penWidth)/2)

            ;;Draw the line
            pg.MoveTo(start_x,start_y)
            pg.LineTo(end_x,end_y)
            pg.Stroke()

            ;;If we changed the line color then revert back to the default color
            if (^passed(aColor) && (aColor != this.StrokeColor))
                resetStrokeColor()

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a line based on absolute X,Y positions. The current position is NOT
        ;;; updated by line drawing.
        ;;; </summary>
        ;;; <param name="aFromX">Origin X position.</param>
        ;;; <param name="aFromY">Origin Y position.</param>
        ;;; <param name="aToRow">Destination X position.</param>
        ;;; <param name="aToCol">Destination Y position.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 1.</param>
        ;;; <param name="aColor">Line color.</param>
        public method DrawLineAbsolute, void
            required in aFromX, float
            required in aFromY, float
            required in aToX,   float
            required in aToY,   float
            optional in aWidth, float
            optional in aColor, PdfColor
            endparams
            record
                penWidth,   float
            endrecord
        proc
            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific color then use it
            if (^passed(aColor) && (aColor != this.StrokeColor))
                setCustomStrokeColor(aColor)

            ;;Draw the line
            pg.MoveTo(aFromX,aFromY)
            pg.LineTo(aToX,aToY)
            pg.Stroke()

            ;;If we changed the line color then revert back to the default color
            if (^passed(aColor) && (aColor != this.StrokeColor))
                resetStrokeColor()

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the line defined by a PdfLine object.
        ;;; </summary>
        ;;; <param name="aLineObj">PdfLine object to be displayed.</param>
        public method DrawLine, void
            required in aLineObj, @PdfLine
        proc
            if (aLineObj.is.PdfLineRowCol) then
                DrawLine(((PdfLineRowCol)aLineObj).FromRow,((PdfLineRowCol)aLineObj).FromCol,((PdfLineRowCol)aLineObj).ToRow,((PdfLineRowCol)aLineObj).ToCol,((PdfLineRowCol)aLineObj).Width,((PdfLineRowCol)aLineObj).Color)
            else if (aLineObj.is.PdfLineAbsolute)
                DrawLineAbsolute(((PdfLineAbsolute)aLineObj).FromX,((PdfLineAbsolute)aLineObj).FromY,((PdfLineAbsolute)aLineObj).ToX,((PdfLineAbsolute)aLineObj).ToY,((PdfLineAbsolute)aLineObj).Width,((PdfLineAbsolute)aLineObj).Color)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a box from the center of specified start and end cells.
        ;;; The default from point is the current position.
        ;;; The default end point is the bottom right corner of the page.
        ;;; The current position is NOT updated by this method.
        ;;; </summary>
        ;;; <param name="aFromRow">Top left corner row.</param>
        ;;; <param name="aFromCol">Top left corner column.</param>
        ;;; <param name="aToRow">Bottom right corner row.</param>
        ;;; <param name="aToCol">Bottom right corner column.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 1.</param>
        ;;; <param name="aColor">Line color.</param>
        ;;; <param name="aFill">Should the box be filled by the specified color?</param>
        public method DrawBox, void
            optional in aFromRow,       int
            optional in aFromColumn,    int
            optional in aToRow,         int
            optional in aToColumn,      int
            optional in aWidth,         float
            optional in aColor,         PdfColor
            optional in aFill,          boolean
            endparams
            record
                lFromRow,               int
                lFromColumn,            int
                lToRow,                 int
                lToColumn,              int
                penWidth,               float
                start_x,                float
                start_y,                float
                end_x,                  float
                end_y,                  float
            endrecord
        proc
            ;;Define origin row
            if (^passed(aFromRow) && (aFromRow > 0) && (aFromRow < this.Rows)) then
                lFromRow = aFromRow
            else
                lFromRow = this.Row

            ;;Define origin column
            if (^passed(aFromColumn) && (aFromColumn > 0) && (aFromColumn < this.Columns)) then
                lFromColumn = aFromColumn
            else
                lFromColumn = this.Column

            ;;Define destination row
            if (^passed(aToRow) && (aToRow > lFromRow) && (aToRow <= this.Rows)) then
                lToRow = aToRow
            else
                lToRow = this.Rows

            ;;Define destination column
            if (^passed(aToColumn) && (aToColumn > lFromColumn) && (aToColumn <= this.Columns)) then
                lToColumn = aToColumn
            else
                lToColumn = this.Columns

            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific color then use it
            if (^passed(aColor) && (aColor != this.StrokeColor))
                setCustomStrokeColor(aColor)

            if (^passed(aColor) && (aColor != this.FillColor))
                setCustomFillColor(aColor)

            ;;Calculate the start and end points for a center cell to center cell line
            start_x = XfromCol(lFromColumn) + (this.ColumnWidth / 2)
            start_y = Body_YfromRow(lFromRow) + ((this.RowHeight-penWidth)/2)
            end_x   = XfromCol(lToColumn) + (this.ColumnWidth/ 2)
            end_y   = Body_YfromRow(lToRow) + ((this.RowHeight-penWidth)/2)

            ;;Define the box (this enters graphics mode)
            pg.Rectangle(start_x,start_y,end_x-start_x,end_y-start_y)

            ;;Draw the box (this exits graphics mode and returns to text mode)
            if (^passed(aFill) && aFill) then
                pg.FillStroke()
            else
                pg.Stroke()

            ;;If we changed the line color then revert back to the default color
            if (^passed(aColor) && (aColor != this.StrokeColor))
                resetStrokeColor()

            if (^passed(aColor) && (aColor != this.FillColor))
                resetFillColor()

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a box from the center of specified start and end cells.
        ;;; The default from point is the current position.
        ;;; The default end point is the bottom right corner of the page.
        ;;; The current position is NOT updated by this method.
        ;;; </summary>
        ;;; <param name="aFromX">Top left corner X coordinate.</param>
        ;;; <param name="aFromY">Top left corner Y coordinate.</param>
        ;;; <param name="aToX">Bottom right corner X coordinate.</param>
        ;;; <param name="aToY">Bottom right corner Y coordinate.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 1.</param>
        ;;; <param name="aColor">Line color.</param>
        ;;; <param name="aFill">Should the box be filled by the specified color?</param>
        public method DrawBoxAbsolute, void
            required in aFromX,     float
            required in aFromY,     float
            required in aToX,       float
            required in aToY,       float
            optional in aWidth,     float
            optional in aColor,     PdfColor
            optional in aFill,      boolean
            endparams
            record
                penWidth,       float
            endrecord
        proc
            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific color then use it
            if (^passed(aColor) && (aColor != this.StrokeColor))
                setCustomStrokeColor(aColor)

            if (^passed(aColor) && (aColor != this.FillColor))
                setCustomFillColor(aColor)

            ;;Define the box (this enters graphics mode)
            pg.Rectangle(aFromX,aFromY,aToX-aFromX,aToY-aFromY)

            ;;Draw the box (this exits graphics mode and returns to text mode)
            if (^passed(aFill) && aFill) then
                pg.FillStroke()
            else
                pg.Stroke()

            ;;If we changed the line color then revert back to the default color
            if (^passed(aColor) && (aColor != this.StrokeColor))
                resetStrokeColor()

            if (^passed(aColor) && (aColor != this.FillColor))
                resetFillColor()

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the box defined by a PdfBox object.
        ;;; </summary>
        ;;; <param name="aBoxObj">PdfBox object to be displayed.</param>
        public method DrawBox, void
            required in aBoxObj, @PdfBox
        proc
            if (aBoxObj.is.PdfBoxRowCol) then
            begin
                data b, @PdfBoxRowCol, (PdfBoxRowCol)aBoxObj
                DrawBox(b.FromRow,b.FromCol,b.ToRow,b.ToCol,b.Width,b.Color,b.Fill)
            end
            else if (aBoxObj.is.PdfBoxAbsolute)
            begin
                data b, @PdfBoxAbsolute, (PdfBoxAbsolute)aBoxObj
                DrawBoxAbsolute(b.FromX,b.FromY,b.ToX,b.ToY,b.Width,b.Color,b.Fill)
            end
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Loads a JPEG or PNG image and displays it at a specified position on the current page.
        ;;; Note that if you specify height and width then you should try to maintain the same ratio
        ;;; as the dimensions of the actual image, otherwise the image will be stretched or shrunk
        ;;; in order to achieve the dimensions that you specify.
        ;;; </summary>
        ;;; <param name="aFileSpec">Full or relative file spec of the image to load (.jpg, .jpeg or .png).</param>
        ;;; <param name="aOriginX">X position of the bottom left corner of the image on the current page.</param>
        ;;; <param name="aOriginY">Y position of the bottom left corner of the image on the current page.</param>
        ;;; <param name="aWidth">Width to occupy in device independent pixels (defaults to the pixel width of the image).</param>
        ;;; <param name="aWidth">Height to occupy in device independent pixels (defaults to the pixel height of the image).</param>
        public method DrawImage, void
            required in aFileSpec, string
            required in aX, float
            required in aY, float
            optional in aWidth, float
            optional in aHeight, float
            record
                image, @HPdfImage
                width, float
                height, float
            endrecord
        proc
            if (aFileSpec.Trim().ToLower().EndsWith(".jpg") || aFileSpec.Trim().ToLower().EndsWith(".jpeg")) then
                image = doc.LoadJpegImageFromFile(aFileSpec)
            else if (aFileSpec.Trim().ToLower().EndsWith(".png"))
                image = doc.LoadPngImageFromFile(aFileSpec)

            if (image != ^null)
            begin
                if (^passed(aWidth) && aWidth) then
                    width = aWidth
                else
                    width = image.GetWidth()

                if (^passed(aHeight) && aHeight) then
                    height = aHeight
                else
                    height = image.GetHeight()

                pg.DrawImage(image,aX,aY,width,height)

            end

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the image defined by a PdfImage object.
        ;;; </summary>
        ;;; <param name="aImageObj">PdfImage object to be displayed.</param>
        public method DrawImage, void
            required in aImageObj, @PdfImage
        proc
            DrawImage(aImageObj.FileSpec,aImageObj.X,aImageObj.Y,aImageObj.Width,aImageObj.Height)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Sets the current position to the beginning of the next line. If the next line
        ;;; is outside of the page body then a new page is generated.
        ;;; </summary>
        ;;; <returns>Returns the new current row number.</returns>
        public method NewLine, int
        proc
            if (this.Row < this.Rows) then
            begin
                this.Row = this.Row + 1
                this.Column = 1
            end
            else
            begin
                NewPage()
            end

            mreturn this.Row

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Starts a new page.
        ;;; </summary>
        ;;; <returns>Returns the new page number.</returns>
        public method NewPage, int
        proc
            ;;Print page level items on the current page
            printPageItems()

            ;;Add a new page to the PDF file
            pg = doc.AddPage(HPdfPageSizes.HPDF_PAGE_SIZE_LETTER,getHaruPageDirection())

            ;;Activate the font for the new page
            pg.StartPageWithFont(fontNormal,fontSizeFloat)
            pg.EndText()

            ;;Make sure that text is drawn as solid letters, not an outline with a seperate fill
            pg.SetTextRenderingMode(HPdfTextRenderingMode.HPDF_FILL)

            ;;Set any custom page background color
            setPageBackroundColor()

            ;;Put the default colors in place for the new page
            pg.SetRGBFill(textRed,textGreen,textBlue)
            pg.SetRGBStroke(lineRed,lineGreen,lineBlue)

            ;;Record the new page number and reset the page's current row counter
            this.PageNumber = this.PageNumber + 1
            this.Row = 1
            this.Column = 1

            mreturn this.PageNumber

        endmethod

.ifdef D_GUI
        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Displays the report in a print preview window. The Dispose method is called
        ;;; after the preview is launched, so after calling this method the PdfFile object
        ;;; is no longer valid.
        ;;; </summary>
        ;;; <returns>Returns true if the PDF file was saved and launched.</returns>
        public method Preview, boolean
        proc
            if (SaveToFile()) then
            begin
                ;;And launch the associated application
                xcall shell(,'"'+this.FileLocation+this.FileName+'"',D_NOCONSOLE|D_NOWAIT)
            end
            else
            begin
                ;;Error message already set by SaveToFile()
                mreturn false
            end

            ;;Clean up
            Dispose()

            mreturn true

        endmethod
.endc
        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Saves the PDF file to disk.
        ;;; </summary>
        ;;; <returns>Returns true if the PDF file was successfully saved.</returns>
        public method SaveToFile, boolean
        proc
            ;;Print page level items on the last page
            printPageItems()

            ;;Create the PDF file on disk
            try
            begin
                doc.SaveToFile(this.FileLocation+this.FileName)
            end
            catch (ex)
            begin
                this.ErrorMessage = "Failed to save file " + this.FileLocation+mFileName
                mreturn false
            end
            endtry

            mreturn true

        endmethod

        ;;********************************************************************************
        ;;PUBLIC PROPERTIES

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the name of the author of the PDF document.
        ;;; </summary>
        public property Author, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_AUTHOR)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_AUTHOR,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mAutoItems, @ArrayList

        ;;; <summary>
        ;;; Gets or sets a collection of auto objects that are to be drawn on each page.
        ;;; </summary>
        public property AutoItems, @ArrayList
            method get
            proc
                mreturn mAutoItems
            endmethod
            method set
            proc
                mAutoItems = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mBottomMargin, float

        ;;; <summary>
        ;;; Gets the height of the bottom margin in inches. Page margins are determined by parameters that are passed to the constructor and once defined cannot be changed. Margins only affect row and column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property BottomMargin, float
            method get
            proc
                mreturn mBottomMargin
            endmethod
            private method set
            proc
                mBottomMargin = value
                bottomOffset = mBottomMargin * 72
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mCenterBodyInPage, boolean

        ;;; <summary>
        ;;; Gets whether the main page body (the printable area inside any specified margins) will be centered horizontally. The default value is true, and this can be overridden via a parameter passed to the Initialize method. When true, after an appropriate font size has been calculated in order to facilitate the required column width of the document, the left and right margins are altered in order to ensure than content is centered horizontally within each page. Page margins and body only affect row / column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property CenterBodyInPage, int
            method get
            proc
                mreturn mCenterBodyInPage
            endmethod
            private method set
            proc
                mCenterBodyInPage = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mColumn, int

        ;;; <summary>
        ;;; Gets or sets the current column number. The concept of a current row and column is used when accessing the document by row and column, and is similar to the concept of current cursor position on the screen of a character based application. Generally, when displaying text to the document via the various methods that address row and column, the current position in the document moves either immediately after the printed text, or to the first column of the next row. Current row and column do not affect absolute positioning access to the document.
        ;;; </summary>
        public property Column, int
            method get
            proc
                mreturn mColumn
            endmethod
            method set
            proc
                mColumn = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mColumns, int

        ;;; <summary>
        ;;; Gets the number of columns that are available, based on the requested margins and page width, at the selected font size. The number of columns actually available will generally to be equal to or greater to the number of columns requested via the optional "minimum columns" parameter passed to the Initialize method. The number of available columns is only applicable when accessing the document by row and column, and does not affect absolute positioning access to the document.
        ;;; </summary>
        public property Columns, int
            method get
            proc
                mreturn mColumns
            endmethod
            private method set
            proc
                mColumns = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mColumnWidth, float

        ;;; <summary>
        ;;; Gets the width of a single column in device independent pixels (1/72 inch). The width is based on the font that was selected in order to achieve the number of columns required for the page. Column width is only applicable to row/column based access to the document using the default Courier font and has no significance when addressing the document via absolute positioning or alternate fonts.
        ;;; </summary>
        public property ColumnWidth, float
            method get
            proc
                mreturn mColumnWidth
            endmethod
            private method set
            proc
                mColumnWidth = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets the creation date of the document.
        ;;; </summary>
        public property CreationDate, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_CREATION_DATE)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the name of the creator of the PDF document. By default this property is set to "Synergex PSG PdfFile Class".
        ;;; </summary>
        public property Creator, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_CREATOR)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_CREATOR,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mErrorMessage, string

        ;;; <summary>
        ;;; Gets the last error message. This property is populated by the methods that return a boolean (success) status. If a method returns a false status then the ErrorMessage property will contain a description of the reason for the failure.
        ;;; </summary>
        public property ErrorMessage, string
            method get
            proc
                mreturn mErrorMessage
            endmethod
            private method set
            proc
                mErrorMessage = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFileLocation, string

        ;;; <summary>
        ;;; Gets the location where the output file will be created as a full windows path including a trailing \.
        ;;; </summary>
        public property FileLocation, string
            method get
            proc
                mreturn mFileLocation
            endmethod
            private method set
            proc
                mFileLocation = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFileName, string

        ;;; <summary>
        ;;; Gets the name of the PDF file being created. The default name of the file will be in the format "YYYY-MM-DD HH.MM.SS <name> .pdf" where the value of <name> can be supplied via the optional "partial file name" parameter to the Initialize method. The name of the file is not used until you call either the Preview or SaveToFile methods, so you may update the value of the property in order to override the default name until that time.
        ;;; </summary>
        public property FileName, string
            method get
            proc
                mreturn mFileName
            endmethod
            private method set
            proc
                mFileName = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFillColor, PdfColor
        private textRed,    float
        private textGreen,  float
        private textBlue,   float

        ;;; <summary>
        ;;; Gets or sets the current fill color, which is the colur used to paint the internal areas of both text and lines, and boxes if the optional "fill" parameter is passed and true. The default fill color is black. The default fill color can be overridden when printing or drawing individual text, line or box items.
        ;;; </summary>
        public property FillColor, PdfColor
            method get
            proc
                mreturn mFillColor
            endmethod
            method set
            proc
                mFillColor = value
                rgbFromPdfColor(mFillColor,textRed,textGreen,textBlue)
                pg.SetRGBFill(textRed,textGreen,textBlue)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFontSize, int
        private fontSizeFloat, float

        ;;; <summary>
        ;;; Gets the height of the default (automatically selected) font in device independent pixels (1/72 inch). The FontSize only has relevance when addressing the document using the default (Coruier) font.
        ;;; </summary>
        public property FontSize, int
            method get
            proc
                mreturn mFontSize
            endmethod
            private method set
            proc
                mFontSize = value
                fontSizeFloat = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFooterRows, int

        ;;; <summary>
        ;;; Gets the number of footer rows that were reserved when the document was created. Footer rows are only relevant when using the FooterText property, and have no affect when accessing the document via absolute positioning mechanisms.
        ;;; </summary>
        public property FooterRows, int
            method get
            proc
                mreturn mFooterRows
            endmethod
            private method set
            proc
                mFooterRows = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFooterText, [#]string

        ;;; <summary>
        ;;; Gets or sets the array of strings to be displayed in the reserved page footer rows. The array is initialized based on the number of footer rows requested when calling the constructor, and can subsequently be populated with the data to be displayed in the reserved footer area of each page.
        ;;; </summary>
        public property FooterText, [#]string
            method get
            proc
                mreturn mFooterText
            endmethod
            private method set
            proc
                mFooterText = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mHeaderRows, int

        ;;; <summary>
        ;;; Gets the number of header rows that were reserved when the document was created. Header rows are only relevant when using the FooterText property, and have no affect when accessing the document via absolute positioning mechanisms.
        ;;; </summary>
        public property HeaderRows, int
            method get
            proc
                mreturn mHeaderRows
            endmethod
            private method set
            proc
                mHeaderRows = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mHeaderText, [#]string

        ;;; <summary>
        ;;; Gets or sets the array of strings to be displayed in the reserved page header rows. The array is initialized based on the number of header rows requested when calling the constructor, and can subsequently be populated with the data to be displayed in the reserved header area of each page.
        ;;; </summary>
        public property HeaderText, [#]string
            method get
            proc
                mreturn mHeaderText
            endmethod
            private method set
            proc
                mHeaderText = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mHeight, int

        ;;; <summary>
        ;;; Gets the height of the page in device independent pixels (1/72 inch). The height of the page is based on the paper size and orientation and defines the maximum value for Y coordinates when addressing the document via absolute positioning mechanisms.
        ;;; </summary>
        public property Height, int
            method get
            proc
                mreturn mHeight
            endmethod
            private method set
            proc
                mHeight = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the keywords of the PDF document.
        ;;; </summary>
        public property Keywords, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_KEYWORDS)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_KEYWORDS,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mLeftMargin, float

        ;;; <summary>
        ;;; Gets the width of the left margin in inches. Page margins are determined by parameters that are passed to the constructor and once defined cannot be changed. Margins only affect row and column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property LeftMargin, float
            method get
            proc
                mreturn mLeftMargin
            endmethod
            private method set
            proc
                mLeftMargin = value
                leftOffset = mLeftMargin * 72
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets the modification date attribute of the PDF document.
        ;;; </summary>
        public property ModificationDate, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_MOD_DATE)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mOrientation, PdfOrientation

        ;;; <summary>
        ;;; Gets the page orientation (portrait or landscape) of the PDF document. The page orientation is defined for the document when calling the constructor method and cannot be changed.
        ;;; </summary>
        public property Orientation, PdfOrientation
            method get
            proc
                mreturn mOrientation
            endmethod
            private method set
            proc
                mOrientation = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mPageBackgroundColor,   PdfColor
        private pageBackgroundRed,  float
        private pageBackgroundGreen,    float
        private pageBackgroundBlue, float

        ;;; <summary>
        ;;; Gets or sets the page background color. A custom value for page background color can be established via an optional parameter passed to the constructor method, and will be used for the first page. Subsequently changing the page background color will affect only new pages that are created after the background color is changed. There is no way to change the background color of a page after the page has been created. The default page background color is white.
        ;;; </summary>
        public property PageBackgroundColor, PdfColor
            method get
            proc
                mreturn mPageBackgroundColor
            endmethod
            method set
            proc
                mPageBackgroundColor = value
                rgbFromPdfColor(mPageBackgroundColor,pageBackgroundRed,pageBackgroundGreen,pageBackgroundBlue)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mPageNumber, int

        ;;; <summary>
        ;;; Gets the current page number. New pages can be created implicitly if performing "sequential writes" to the document, or explicitly by calling the the NewPage method. Once the document advances to a new page there is no way to go back to address earlier pages.
        ;;; </summary>
        public property PageNumber, int
            method get
            proc
                mreturn mPageNumber
            endmethod
            private method set
            proc
                mPageNumber = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRequestedColumns, int

        ;;; <summary>
        ;;; Number of columns originally requested by the consuler.
        ;;; </summary>
        public property RequestedColumns, int
            method get
            proc
                mreturn mRequestedColumns
            endmethod
            private method set
            proc
                mRequestedColumns = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRightMargin, float

        ;;; <summary>
        ;;; Gets the width of the right margin in inches. Page margins are determined by parameters that are passed to the constructor and once defined cannot be changed. Margins only affect row and column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property RightMargin, float
            method get
            proc
                mreturn mRightMargin
            endmethod
            private method set
            proc
                mRightMargin = value
                rightOffset = mRightMargin * 72
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRow, int

        ;;; <summary>
        ;;; Gets or sets the current row number. The concept of a current row and column is used when accessing the document by row and column, and is similar to the concept of current cursor position on the screen of a character based application. Generally, when displaying text to the document via the various methods that address row and column, the current position in the document moves either immediately after the printed text, or to the first column of the next row. Current row and column do not affect absolute positioning access to the document.
        ;;; </summary>
        public property Row, int
            method get
            proc
                mreturn mRow
            endmethod
            method set
            proc
                mRow = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRowHeight, float

        ;;; <summary>
        ;;; Height of a row in device independent pixels (1/72 inch).
        ;;; </summary>
        public property RowHeight, float
            method get
            proc
                mreturn mRowHeight
            endmethod
            private method set
            proc
                mRowHeight = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRows, int

        ;;; <summary>
        ;;; Gets the number of rows that are available within the page body (i.e. between any top margin, header rows, footer rows and bottom margin), based on the page height, the requested top and bottom margins, and the number and height of any page header and footer rows, at the selected font size. The number of available rows is only applicable when accessing the document by row and column mechanisms and has no effect when accessing to the document via absolute positioning mechanisms.
        ;;; </summary>
        public property Rows, int
            method get
            proc
                mreturn mRows
            endmethod
            private method set
            proc
                mRows = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mStrokeColor,   PdfColor
        private lineRed,    float
        private lineGreen,  float
        private lineBlue,   float

        ;;; <summary>
        ;;; Gets or sets the current stroke color, which is the color used to paint the outside edge of lines, boxes and text. The default stroke color is black. The default stroke color can be overridden when printing or drawing individual text, line or box items.
        ;;; </summary>
        public property StrokeColor, PdfColor
            method get
            proc
                mreturn mStrokeColor
            endmethod
            method set
            proc
                mStrokeColor = value
                rgbFromPdfColor(mStrokeColor,lineRed,lineGreen,lineBlue)
                pg.SetRGBStroke(lineRed,lineGreen,lineBlue)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the subject attribute of the PDF document.
        ;;; </summary>
        public property Subject, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_SUBJECT)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_SUBJECT,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the title attribute of the PDF document.
        ;;; </summary>
        public property Title, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_TITLE)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_TITLE,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mTopMargin, float

        ;;; <summary>
        ;;; Gets the height of the top margin in inches. Page margins are determined by parameters that are passed to the constructor and once defined cannot be changed. Margins only affect row and column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property TopMargin, float
            method get
            proc
                mreturn mTopMargin
            endmethod
            private method set
            proc
                mTopMargin = value
                topOffset = mTopMargin * 72
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mWidth, int

        ;;; <summary>
        ;;; Gets the width of the page in device independent pixels (1/72 inch). The width of the page is based on the paper size and orientation and defines the maximum value for X coordinates when addressing the document via absolute positioning mechanisms.
        ;;; </summary>
        public property Width, int
            method get
            proc
                mreturn mWidth
            endmethod
            private method set
            proc
                mWidth = value
            endmethod
        endproperty

    endclass

endnamespace

