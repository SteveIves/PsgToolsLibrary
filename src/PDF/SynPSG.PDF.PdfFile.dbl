;;*****************************************************************************
;;
;; File:        SynPSG.PDF.PdfFile.dbl
;;
;; Title:       PdfFile
;;
;; Type:        Partial Class (see also SynPSG.PfdFile.Private.dbl)
;;
;; Description: Provides the ability to create a PDF file. This class provides
;;              a more usable wrapper around the underlying functionality that
;;              is defined in the Synergy/DE CodeExchange item named "pdfkit",
;;              which in turn provides a DBL wrapper around the open source
;;              "libHaru" PDF library.
;;
;;              In order to use this class and other related classes you must:
;;
;;              1. Include the "pdfkit" source code in the same library as this
;;                 class by including the source file pdfdbl.db in your build.
;;
;;              2. Deploy the libHaru DLL's that are distributed with "pdfkit"
;;                 by copying them to your dbl\bin folder.
;;
;; Date:        19th July 2015
;;
;; Author:      Steve Ives, Synergex Professional Services Group
;;              http://www.synergex.com
;;
;;*****************************************************************************
;;
;; Copyright (c) 2015, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import System.Collections
import SynPSG
import HPdf
import system
import synpsg

namespace SynPSG.PDF

    ;;; <summary>
    ;;; Provides the ability to create a PDF file. This class provides a more usable
    ;;; wrapper around the underlying functionality defined in the "pdfkit" item
    ;;; from the Synergy/DE CodeExchange
    ;;; </summary>
    public partial class PdfFile

        private doc,                            @HPdfDoc
        private fontNormal,                     @HPdfFont
        private fontBold,                       @HPdfFont
        private fontItalic,                     @HPdfFont
        private fontBoldItalic,                 @HPdfFont
        private pg,                             @HpdfPage

        private leftOffset,                     float   ;Pixels reserved for requested left margin
        private topOffset,                      float   ;Pixels reserved for requested top margin
        private rightOffset,                    float   ;Pixels reserved for requested right margin
        private bottomOffset,                   float   ;Pixels reserved for requested bottom margin

        private totalHeightDefaultOrientation,  float
        private totalHeightOtherOrientation,    float

        private totalWidthDefaultOrientation,   float
        private totalWidthOtherOrientation,     float

        private totalRowsDefaultOrientation,    int     ;Total number of rows for the entire page (default orientation)
        private totalColsDefaultOrientation,    int     ;Total number of cols for the entire page (default orientation)

        private totalRowsOtherOrientation,      int     ;Total number of rows for the entire page (other orientation)
        private totalColsOtherOrientation,      int     ;Total number of cols for the entire page (other orientation)

        private pageIsNew,                      boolean

        ;;********************************************************************************
        ;;CONSTRUCTOR

        ;;; <summary>
        ;;; Constructs a new PdfFile object.
        ;;; </summary>
        ;;; <param name="aPageSize">Size of pages in the document.</param>
        ;;; <param name="aOrientation">Default orientation of pages, portrait or landscape.</param>
        ;;; <param name="aLeftMargin">Establishes a left margin for the pages of the document. The value is specified in inches. If you don't specify a left margin then a default value of 0.16 inches will be used. If you don't want any margin then specify a value of 0.</param>
        ;;; <param name="aTopMargin">Establishes a top margin for the pages of the document. The value is specified in inches. If you don't specify a left margin then a default value of 0.16 inches will be used. If you don't want any margin then specify a value of 0.</param>
        ;;; <param name="aRightMargin">Establishes a right margin for the pages of the document. The value is specified in inches. If you don't specify a left margin then a default value of 0.16 inches will be used. If you don't want any margin then specify a value of 0.</param>
        ;;; <param name="aBottomMargin">Establishes a bottom margin for the pages of the document. The value is specified in inches. If you don't specify a left margin then a default value of 0.16 inches will be used. If you don't want any margin then specify a value of 0.</param>
        ;;; <param name="aHeaderRows">Establishes the number of header rows that are to be allocated on each page of the document. Header rows are displayed below the top margin and above the main body of each page of the document.</param>
        ;;; <param name="aFooterRows">Establishes the number of footer rows that are to be allocated on each page of the document. Footer rows are displayed below main body and above the bottom margin of each page of the document.</param>
        ;;; <param name="aPageBackgroundColor">Establishes a custom page background color and implements that color on the first page. The default page background color is white.</param>
        public method PdfFile
            optional in aPageSize,              PdfPageSize
            optional in aOrientation,           PdfOrientation
            optional in aLeftMargin,            float
            optional in aTopMargin,             float
            optional in aRightMargin,           float
            optional in aBottomMargin,          float
            optional in aHeaderRows,            int
            optional in aFooterRows,            int
            optional in aPageBackgroundColor,   PdfColor
        proc

            ;;Set page orientation
            if (^passed(aPageSize)) then
                this.PageSize = aPageSize
            else
                this.PageSize = PdfPageSize.LETTER

            ;;Set default page orientation
            if (^passed(aOrientation)) then
                this.DefaultOrientation = aOrientation
            else
                this.DefaultOrientation = PdfOrientation.Portrait

            ;;Create a new PDF document
            doc = new HPdfDoc()

            ;;Set the document compression mode
;           doc.SetCompressionMode(HPDF_COMP_ALL)

            ;;Load the fonts we'll be using
            fontNormal = doc.GetFont("Courier", ^null)
            fontBold = doc.GetFont("Courier-Bold", ^null)
            fontItalic = doc.GetFont("Courier-Oblique", ^null)
            fontBoldItalic = doc.GetFont("Courier-BoldOblique", ^null)

            ;;Start the first page
            pg = doc.AddPage((HPdfPageSizes)this.PageSize,(HPdfPageDirection)this.DefaultOrientation)
            this.Orientation = this.DefaultOrientation

            ;;Get the pixel dimensions of the page
            totalHeightDefaultOrientation = %integer(pg.GetHeight())
            totalWidthDefaultOrientation = %integer(pg.GetWidth())
            totalHeightOtherOrientation = totalWidthDefaultOrientation
            totalWidthOtherOrientation = totalHeightDefaultOrientation

            this.Height = totalHeightDefaultOrientation
            this.Width = totalWidthDefaultOrientation

            ;;Left margin
            if (^passed(aLeftMargin) && (aLeftMargin >= 0)) then
                this.LeftMargin = aLeftMargin
            else
                this.LeftMargin = 0.16

            ;;Top margin
            if (^passed(aTopMargin) && (aTopMargin >= 0)) then
                this.TopMargin = aTopMargin
            else
                this.TopMargin = 0.16

            ;;Right margin
            if (^passed(aRightMargin) && (aRightMargin >= 0)) then
                this.RightMargin = aRightMargin
            else
                this.RightMargin = 0.16

            ;;Bottom margin
            if (^passed(aBottomMargin) && (aBottomMargin>=0)) then
                this.BottomMargin = aBottomMargin
            else
                this.BottomMargin = 0.16

            ;;Start with a "normal" font size
            this.FontSize = 12

            ;;Start a text writer with the current font and size
            pg.StartPageWithFont(fontNormal,fontSizeFloat)

            ;;Make sure that text is drawn as solid letters, not an outline with a seperate fill
            pg.SetTextRenderingMode(HPdfTextRenderingMode.HPDF_FILL)

            ;;Calculate the page dimensions in rows and columns based on the current font
            this.RowHeight = fontSizeFloat
            this.ColumnWidth = pg.TextWidth("W")

            totalRowsDefaultOrientation = %truncate((this.Height-topOffset-bottomOffset)/this.RowHeight)
            totalColsDefaultOrientation = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)

            totalRowsOtherOrientation = %truncate((this.Width-topOffset-bottomOffset)/this.RowHeight)
            totalColsOtherOrientation = (int)%truncate((this.Height-leftOffset-rightOffset)/this.ColumnWidth)

            ;;Close off the page for now, not sure if we'll need text or graphics first
            pg.EndText()

            ;;Were header rows requested?
            if (^passed(aHeaderRows) && aHeaderRows)
            begin
                data ix, int
                this.HeaderRows = aHeaderRows
                this.HeaderText = new string[this.HeaderRows]
                for ix from 1 thru this.HeaderRows
                    this.HeaderText[ix] = ""
            end

            ;;Were footer rows requested?
            if (^passed(aFooterRows) && aFooterRows)
            begin
                data ix, int
                this.FooterRows = aFooterRows
                this.FooterText = new string[this.FooterRows]
                for ix from 1 thru this.FooterRows
                    this.FooterText[ix] = ""
            end

            ;;Set the body dimensions for the default orientation
            this.Rows = totalRowsDefaultOrientation - this.HeaderRows - this.FooterRows
            this.Columns = totalColsDefaultOrientation

            ;;Set the default colors to black
            this.StrokeColor = PdfColor.Black
            this.FillColor = PdfColor.Black
            this.PageBackgroundColor = PdfColor.White

            ;;Initialize the auto items collection
            this.AutoItems = new ArrayList()

            ;;If we were given a custom backgound color then save it
            if (^passed(aPageBackgroundColor) && (aPageBackgroundColor != PageBackgroundColor))
            begin
                PageBackgroundColor = aPageBackgroundColor
                ;;And use it for the first page
                setPageBackroundColor()
            end

            ;Set the default creator name
            this.Creator = "Synergex PSG PdfFile Class"

            ;;Make sure auto begin page items are added to the first page
            pageIsNew = true

            ;;Make sure the error message property is blank not null
            this.ErrorMessage = ""

        endmethod

        ;;********************************************************************************
        ;;PUBLIC METHODS

        ;------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Adds a design grid to all pages of the document (via the AutoItems collection).
        ;;; </summary>
        public method AddDesignGrid, void
            endparams
            record
                x, float
                y, float
            endrecord
        proc
            this.SelectFont("Helvetica",4)

            ;Draw horizontal 5 lines
            y = 0
            while ((y+=5)<=this.Height)
                this.AutoItems.Add(new AutoLineAbsolute(0,y,this.Width,y,0.1,PdfColor.LightGray))

            ;Draw horizontal 10 lines
            y = 0
            while ((y+=10)<=this.Height)
            begin
                this.AutoItems.Add(new AutoLineAbsolute(0,y,this.Width,y,0.5,PdfColor.LightGray))
                this.AutoItems.Add(new AutoTextAbsolute(%string(%integer(y)),0,y+1,PdfColor.Black,"Helvetica",4))
            end

            ;Draw horizontal 100 lines
            y = 0
            while ((y+=100)<=this.Height)
                this.AutoItems.Add(new AutoLineAbsolute(0,y,this.Width,y,0.5,PdfColor.DarkGray))

            ;Draw vertical 5 lines
            x = 0
            while ((x+=5)<=this.Height)
                this.AutoItems.Add(new AutoLineAbsolute(x,0,x,this.Height,0.1,PdfColor.LightGray))

            ;Draw vertical 10 lines
            x = 0
            while ((x+=10)<=this.Height)
            begin
                this.AutoItems.Add(new AutoLineAbsolute(x,0,x,this.Height,0.5,PdfColor.LightGray))
                this.AutoItems.Add(new AutoTextAbsolute(%string(%integer(x)),x,1,PdfColor.Black,"Helvetica",4))
            end

            ;Draw vertical 100 lines
            x = 0
            while ((x+=100)<=this.Height)
                this.AutoItems.Add(new AutoLineAbsolute(x,0,x,this.Height,0.5,PdfColor.DarkGray))

            this.ResetFont()

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Releases resources allocated by the PDF document. After calling this method the PdfFile object is no longer valid. This method is called automatically whenever you call the Preview, Print or Save methods.
        ;;; </summary>
        public method Dispose, void
            endparams
        proc
            doc.FreeDocAll()
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a box from the center of specified start and end cells.
        ;;; The default from point is the current position.
        ;;; The default end point is the bottom right corner of the page.
        ;;; The current position is NOT updated by this method.
        ;;; </summary>
        ;;; <param name="aFromX">Top left corner X coordinate.</param>
        ;;; <param name="aFromY">Top left corner Y coordinate.</param>
        ;;; <param name="aToX">Bottom right corner X coordinate.</param>
        ;;; <param name="aToY">Bottom right corner Y coordinate.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 1.</param>
        ;;; <param name="aStrokeColor">Custom stroke color.</param>
        ;;; <param name="aFill">Should the box be filled?</param>
        ;;; <param name="aFillColor">Custom fill color.</param>
        public method DrawBox,        void
            required in aFromX,       float
            required in aFromY,       float
            required in aToX,         float
            required in aToY,         float
            optional in aWidth,       float
            optional in aStrokeColor, PdfColor
            optional in aFill,        boolean
            optional in aFillColor,   PdfColor
            endparams
            record
                penWidth,       float
            endrecord
        proc
            if (pageIsNew) ;Can't be done in NewPage because it would not happen for the first page!
                printBeginPageItems()

            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific stroke color then use it
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                setCustomStrokeColor(aStrokeColor)

            ;;If we were passed a specific fill color then use it
            if (^passed(aFillColor) && (aFillColor != this.FillColor))
                setCustomFillColor(aFillColor)

            ;;Define the box (this enters graphics mode)
            pg.Rectangle(aFromX,aFromY,aToX-aFromX,aToY-aFromY)

            ;;Draw the box (this exits graphics mode and returns to text mode)
            if (^passed(aFill) && aFill) then
                pg.FillStroke()
            else
                pg.Stroke()

            ;;If we changed the stroke color then revert back to the default color
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                resetStrokeColor()

            ;;If we changed the fill color then revert back to the default color
            if (^passed(aFillColor) && (aFillColor != this.FillColor))
                resetFillColor()

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the box defined by an AutoBoxAbsolute object.
        ;;; </summary>
        ;;; <param name="aBox">AutoBoxAbsolute object to be drawn.</param>

        public method DrawBoxObject, void
            required in aBox, @AutoBoxAbsolute
            endparams
        proc
            DrawBox(aBox.FromX,aBox.FromY,aBox.ToX,aBox.ToY,aBox.Width,aBox.StrokeColor,aBox.Fill,aBox.FillColor)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a box from the center of specified start and end cells.
        ;;; The default from point is the current position.
        ;;; The default end point is the bottom right corner of the page.
        ;;; The current position is NOT updated by this method.
        ;;; </summary>
        ;;; <param name="aFromRow">Top left corner row.</param>
        ;;; <param name="aFromCol">Top left corner column.</param>
        ;;; <param name="aToRow">Bottom right corner row.</param>
        ;;; <param name="aToCol">Bottom right corner column.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 1.</param>
        ;;; <param name="aStrokeColor">Custom stroke color.</param>
        ;;; <param name="aFill">Should the box be filled?</param>
        ;;; <param name="aFillColor">Custom fill color.</param>
        public method DrawBoxRC, void
            optional in aFromRow,       int
            optional in aFromColumn,    int
            optional in aToRow,         int
            optional in aToColumn,      int
            optional in aWidth,         float
            optional in aStrokeColor,   PdfColor
            optional in aFill,          boolean
            optional in aFillColor,     PdfColor
            endparams
            record
                lFromRow,               int
                lFromColumn,            int
                lToRow,                 int
                lToColumn,              int
                penWidth,               float
                start_x,                float
                start_y,                float
                end_x,                  float
                end_y,                  float
            endrecord
        proc
            if (pageIsNew) ;Can't be done in NewPage because it would not happen for the first page!
                printBeginPageItems()

            ;;Define origin row
            if (^passed(aFromRow) && (aFromRow > 0) && (aFromRow < this.Rows)) then
                lFromRow = aFromRow
            else
                lFromRow = this.Row

            ;;Define origin column
            if (^passed(aFromColumn) && (aFromColumn > 0) && (aFromColumn < this.Columns)) then
                lFromColumn = aFromColumn
            else
                lFromColumn = this.Column

            ;;Define destination row
            if (^passed(aToRow) && (aToRow > lFromRow) && (aToRow <= this.Rows)) then
                lToRow = aToRow
            else
                lToRow = this.Rows

            ;;Define destination column
            if (^passed(aToColumn) && (aToColumn > lFromColumn) && (aToColumn <= this.Columns)) then
                lToColumn = aToColumn
            else
                lToColumn = this.Columns

            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific stroke color then use it
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                setCustomStrokeColor(aStrokeColor)

            ;;If we were passed a specific fill color then use it
            if (^passed(aFillColor) && (aFillColor != this.FillColor))
                setCustomFillColor(aFillColor)

            ;;Calculate the start and end points for a center cell to center cell line
            start_x = XfromCol(lFromColumn) + (this.ColumnWidth / 2)
            start_y = Body_YfromRow(lFromRow) + ((this.RowHeight-penWidth)/2)
            end_x   = XfromCol(lToColumn) + (this.ColumnWidth/ 2)
            end_y   = Body_YfromRow(lToRow) + ((this.RowHeight-penWidth)/2)

            ;;Define the box (this enters graphics mode)
            pg.Rectangle(start_x,start_y,end_x-start_x,end_y-start_y)

            ;;Draw the box (this exits graphics mode and returns to text mode)
            if (^passed(aFill) && aFill) then
                pg.FillStroke()
            else
                pg.Stroke()

            ;;If we changed the stroke color then revert back to the default color
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                resetStrokeColor()

            ;;If we changed the fill color then revert back to the default color
            if (^passed(aFillColor) && (aFillColor != this.FillColor))
                resetFillColor()

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the box defined by an AutoBoxRowCol object.
        ;;; </summary>
        ;;; <param name="aBox">AutoBoxRowCol object to be drawn.</param>

        public method DrawBoxObjectRC, void
            required in aBox, @AutoBoxRowCol
            endparams
        proc
            DrawBoxRC(aBox.FromRow,aBox.FromCol,aBox.ToRow,aBox.ToCol,aBox.Width,aBox.StrokeColor,aBox.Fill,aBox.FillColor)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Loads a JPEG or PNG image and displays it at a specified position on the current page.
        ;;; Note that if you specify height and width then you should try to maintain the same ratio
        ;;; as the dimensions of the actual image, otherwise the image will be stretched or shrunk
        ;;; in order to achieve the dimensions that you specify.
        ;;; </summary>
        ;;; <param name="aFileSpec">Full or relative file spec of the image to load (.jpg, .jpeg or .png).</param>
        ;;; <param name="aX">X position of the bottom left corner of the image on the current page.</param>
        ;;; <param name="aY">Y position of the bottom left corner of the image on the current page.</param>
        ;;; <param name="aWidth">Width to occupy in device independent pixels (defaults to the pixel width of the image).</param>
        ;;; <param name="aWidth">Height to occupy in device independent pixels (defaults to the pixel height of the image).</param>
        public method DrawImage,   void
            required in aFileSpec, string
            required in aX,        float
            required in aY,        float
            optional in aWidth,    float
            optional in aHeight,   float
            endparams
            record
                image, @HPdfImage
                width, float
                height, float
            endrecord
        proc
            if (pageIsNew) ;Can't be done in NewPage because it would not happen for the first page!
                printBeginPageItems()

            if (aFileSpec.Trim().ToLower().EndsWith(".jpg") || aFileSpec.Trim().ToLower().EndsWith(".jpeg")) then
                image = doc.LoadJpegImageFromFile(aFileSpec)
            else if (aFileSpec.Trim().ToLower().EndsWith(".png"))
                image = doc.LoadPngImageFromFile(aFileSpec)

            if (image != ^null)
            begin
                if (^passed(aWidth) && aWidth) then
                    width = aWidth
                else
                    width = image.GetWidth()

                if (^passed(aHeight) && aHeight) then
                    height = aHeight
                else
                    height = image.GetHeight()

                pg.DrawImage(image,aX,aY,width,height)

            end

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the image defined by a AutoImage object.
        ;;; </summary>
        ;;; <param name="aImage">AutoImage object to be drawn.</param>
        public method DrawImageObject, void
            required in aImage,        @AutoImage
            endparams
        proc
            DrawImage(aImage.FileSpec,aImage.X,aImage.Y,aImage.Width,aImage.Height)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a line based on absolute X,Y positions. The current position is NOT
        ;;; updated by line drawing.
        ;;; </summary>
        ;;; <param name="aFromX">Origin X position.</param>
        ;;; <param name="aFromY">Origin Y position.</param>
        ;;; <param name="aToX">Destination X position.</param>
        ;;; <param name="aToY">Destination Y position.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 1.</param>
        ;;; <param name="aStrokeColor">Custom stroke color.</param>
        public method DrawLine,       void
            required in aFromX,       float
            required in aFromY,       float
            required in aToX,         float
            required in aToY,         float
            optional in aWidth,       float
            optional in aStrokeColor, PdfColor
            endparams
            record
                penWidth,   float
            endrecord
        proc
            if (pageIsNew) ;Can't be done in NewPage because it would not happen for the first page!
                printBeginPageItems()

            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific stroke color then use it
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                setCustomStrokeColor(aStrokeColor)

            ;;Draw the line
            pg.MoveTo(aFromX,aFromY)
            pg.LineTo(aToX,aToY)
            pg.Stroke()

            ;;If we changed the stroke color then revert back to the default color
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                resetStrokeColor()

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the line defined by a PdfLine object.
        ;;; </summary>
        ;;; <param name="aLine">PdfLine object to be displayed.</param>
        public method DrawLineObject, void
            required in aLine,        @AutoLineAbsolute
            endparams
        proc
            DrawLine(aLine.FromX,aLine.FromY,aLine.ToX,aLine.ToY,aLine.Width,aLine.StrokeColor)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the line defined by a AutoLineRowCol object.
        ;;; </summary>
        ;;; <param name="aLine">AutoLineRowCol object to be drawn.</param>
        public method DrawLineObjectRC, void
            required in aLine, @AutoLineRowCol
            endparams
        proc
            DrawLineRC(aLine.FromRow,aLine.FromCol,aLine.ToRow,aLine.ToCol,aLine.Width,aLine.StrokeColor)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a line from the current cell to the end of the current line. By default
        ;;; the line is drawn from and to the center of the start and end cells, unless
        ;;; fullWidth is passed, in which case the line is drawn from the left side of the
        ;;; first cell to the right side of the last cell. The current position is
        ;;; NOT updated by line drawing.
        ;;; </summary>
        ;;; <param name="aFromRow">Origin cell row.</param>
        ;;; <param name="aFromCol">Origin cell column.</param>
        ;;; <param name="aToRow">Destination cell row.</param>
        ;;; <param name="aToCol">Destination cell column.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 2.</param>
        ;;; <param name="aStrokeColor">Custom stroke color.</param>
        public method DrawLineRC,     void
            required in aFromRow,     int
            required in aFromCol,     int
            required in aToRow,       int
            required in aToCol,       int
            optional in aWidth,       float
            optional in aStrokeColor, PdfColor
            endparams
            record
                penWidth,   float
                start_x,    float
                start_y,    float
                end_x,      float
                end_y,      float
            endrecord
        proc
            if (pageIsNew) ;Can't be done in NewPage because it would not happen for the first page!
                printBeginPageItems()

            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific stroke color then use it
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                setCustomStrokeColor(aStrokeColor)

            ;;Calculate the start and end points for a center cell to center cell line
            start_x = XfromCol(aFromCol) + (this.ColumnWidth / 2)
            start_y = Body_YfromRow(aFromRow) + ((this.RowHeight-penWidth)/2)
            end_x   = XfromCol(aToCol) + (this.ColumnWidth/ 2)
            end_y   = Body_YfromRow(aToRow) + ((this.RowHeight-penWidth)/2)

            ;;Draw the line
            pg.MoveTo(start_x,start_y)
            pg.LineTo(end_x,end_y)
            pg.Stroke()

            ;;If we changed the stroke color then revert back to the default color
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                resetStrokeColor()

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws a horizontal line from the current position to the end of the
        ;;; current line. By default the line is drawn from and to the center of the
        ;;; start and end cells, unless fullWidth is passed, in which case the line is
        ;;; drawn from the left side of the first cell to the right side of the last cell.
        ;;; The current position set to the beginning of the next line.
        ;;; </summary>
        ;;; <param name="aFullWidth">Draw the line the full width of the cells.</param>
        ;;; <param name="aWidth">Line width in pixels. Default is 5.</param>
        ;;; <param name="aStrokeColor">Custom stroke color.</param>
        ;;; <returns>Returns the new current row number.</returns>
        public method DrawLineRow,    int
            optional in aFullWidth,   boolean
            optional in aWidth,       int
            optional in aStrokeColor, PdfColor
            endparams
            record
                penWidth,   float
                start_x,    float
                start_y,    float
                end_x,      float
                end_y,      float
            endrecord
        proc
            if (this.Row > this.Rows)
                NewPage()

            if (pageIsNew) ;Can't be done in NewPage because it would not happen for the first page!
                printBeginPageItems()

            ;;Set the line width
            penWidth = ^passed(aWidth) ? aWidth : 1
            pg.SetLineWidth(penWidth)

            ;;If we were passed a specific stroke color then use it
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                setCustomStrokeColor(aStrokeColor)

            ;;Calculate the start and end points for a center cell to center cell line
            start_x = XfromCol(this.Column) + (this.ColumnWidth / 2)
            start_y = Body_YfromRow(this.Row) + ((this.RowHeight-penWidth)/2)
            end_x   = XfromCol(this.Columns) + (this.ColumnWidth/ 2)
            end_y   = start_y

            ;;If we're being asked for a full-width line then add back in the partial cell pixels
            if (^passed(aFullWidth) && aFullWidth)
            begin
                start_x -= (this.ColumnWidth / 2)
                end_x += (this.ColumnWidth / 2)
            end

            ;;Draw the line
            pg.MoveTo(start_x,start_y)
            pg.LineTo(end_x,end_y)
            pg.Stroke()

            ;;If we changed the stroke color then revert back to the default color
            if (^passed(aStrokeColor) && (aStrokeColor != this.StrokeColor))
                resetStrokeColor()

            ;;Update current position
            this.Row = this.Row + 1
            this.Column = 1

            mreturn this.Row

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws text at the specified absolute position. The current row/column
        ;;; position is NOT affected by this method.
        ;;; </summary>
        ;;; <param name="aText">Text to display.</param>
        ;;; <param name="aX">X coordinate to display text at.</param>
        ;;; <param name="aY">Y coordinate to display text at.</param>
        ;;; <param name="aColor">Display the text in a specific color.</param>
        ;;; <param name="aFontName">Display the text in a specific font.</param>
        ;;; <param name="aFontSize">Display the text in a specific font size.</param>
        public method DrawText,    void
            required in aText,      string
            required in aX,         float
            required in aY,         float
            optional in aColor,     PdfColor
            optional in aFontName,  string
            optional in aFontSize,  int
            endparams
        proc
            if (pageIsNew) ;Can't be done in NewPage because it would not happen for the first page!
                printBeginPageItems()

            if (^passed(aColor) && (aColor != mFillColor))
            begin
                setCustomStrokeColor(aColor)
                setCustomFillColor(aColor)
            end

            if ((^passed(aFontName) && (aFontName!=^null)) || (^passed(aFontSize) && (aFontSize>0)))
            begin
                data tmpFontName, string
                data tmpFontSize, int

                if (^passed(aFontName) && (aFontName!=^null)) then
                    tmpFontName = aFontName
                else
                    tmpFontName = fontNormal.GetFontName()

                if (^passed(aFontSize) && (aFontSize>0)) then
                    tmpFontSize = aFontSize
                else
                    tmpFontSize = mFontSize

                SelectFont(tmpFontName,tmpFontSize)
            end

            pg.BeginText()
            pg.MoveTextPos(aX,aY)
            pg.ShowText(aText)
            pg.EndText()

            if ((^passed(aFontName) && (aFontName!=^null)) || (^passed(aFontSize) && (aFontSize>0)))
                ResetFont()

            if (^passed(aColor) && (aColor != this.FillColor))
            begin
                resetStrokeColor()
                resetFillColor()
            end

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the text defined by an AutoTextAbsolute object.
        ;;; </summary>
        ;;; <param name="aText">AutoTextAbsolute object to be drawn.</param>
        public method DrawTextObject, void
            required in aText, @AutoTextAbsolute
            endparams
        proc
            DrawText(aText.Text,aText.X,aText.Y,aText.Color,aText.FontName,aText.FontSize)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws the text defined by an AutoTextRowCol object.
        ;;; </summary>
        ;;; <param name="aText">AutoTextRowCol object to be drawn.</param>
        public method DrawTextObjectRC, void
            required in aText, @AutoTextRowCol
            endparams
        proc
            DrawTextRC(aText.Text,aText.Row,aText.Col,aText.Bold,aText.Italic,aText.Color,aText.NewLine)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Draws text at the current row/column position and sets the curent position to
        ;;; the cell immediately after the displayed text, or to the last cell on the
        ;;; current line if the text extends beyond the page body.
        ;;; </summary>
        ;;; <param name="aText">Text to display.</param>
        ;;; <param name="aRow">Row within the page body to display text at.</param>
        ;;; <param name="aCol">Column within the page body to display text at.</param>
        ;;; <param name="aBold">Display the text in a bold font.</param>
        ;;; <param name="aItalic">Display the text in an italic font.</param>
        ;;; <param name="aColor">Display the text in a specific color.</param>
        ;;; <param name="aNewLine">Set current position to column 1 on the next line after printing text.</param>
        ;;; <returns>Returns the new current column position.</returns>
        public method DrawTextRC,   int
            required in aText,      string
            optional in aRow,       int
            optional in aCol,       int
            optional in aBold,      boolean
            optional in aItalic,    boolean
            optional in aColor,     PdfColor
            optional in aNewLine,   boolean
            endparams
            record
                row,                int
                col,                int
            endrecord
        proc
            if (pageIsNew) ;Can't be done in NewPage because it would not happen for the first page!
                printBeginPageItems()

            row = ^passed(aRow) ? aRow : this.Row
            col = ^passed(aCol) ? aCol : this.Column

            setFontAttributes(aBold,aItalic)

            if (^passed(aColor) && (aColor != mFillColor))
            begin
                setCustomStrokeColor(aColor)
                setCustomFillColor(aColor)
            end

            pg.BeginText()
            pg.MoveTextPos(XfromCol(col),Body_YFromRow(row))
            pg.ShowText(aText)
            pg.EndText()

            resetFont(aBold,aItalic)

            if (^passed(aColor) && (aColor != this.FillColor))
            begin
                resetStrokeColor()
                resetFillColor()
            end

            if (^passed(aNewLine) && aNewLine) then
            begin
                this.Row = row + 1
                this.Column = 1
            end
            else
            begin
                this.Row = row
                this.Column = col + aText.Length
                if (this.Column > this.Columns)
                    this.Column = this.Columns
            end

            mreturn this.Column

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Initializes the PdfFile for use. You must call initialize before attempting
        ;;; to add any content to the document. The first page is created during initialization.
        ;;; </summary>
        ;;; <param name="aFileLocation">The location where the PDF file should be created. This can either be a path, a logical name followed by a colon.</param>
        ;;; <param name="aPartialFileName">Text to be used as part of the PDF file name.</param>
        ;;; <param name="aMinimumColumns">The minimum number of columns required for the document. An appropriate font size will be determined based on this value.</param>
        ;;; <param name="aMaxFontSize">The maximum font size that you want to be selected. If a larger font is calculated then this font size will be used instead.</param>
        ;;; <param name="aCenterBodyInPage">Should the page be configured for the exact number of columns specified, and the content horizontally centered in the page?</param>
        public method Initialize,           boolean
            optional in  aFileLocation,     string
            optional in  aPartialFileName,  string
            optional in  aMinimumColumns,   int
            optional in  aMaxFontSize,      int
            optional in  aCenterBodyInPage, boolean
            endparams
            record
                ok,         boolean
                attempts,       int
            endrecord
        proc
            ;;Define the output file location
            if (^passed(aFileLocation) && (aFileLocation.Trim().Length > 0)) then
            begin
                this.FileLocation = expandLogicalInFileSpec(aFileLocation)
                if (this.FileLocation == %char(0)) then
                begin
                    this.ErrorMessage = "Invalid location " + aFileLocation
                    mreturn false
                end
                else
                begin
                    if (!this.FileLocation.Trim().EndsWith("\"))
                        this.FileLocation = this.FileLocation.Trim() + "\"
                end
            end
            else
            begin
                this.FileLocation = expandLogicalInFileSpec("TEMP:")
                if (!this.FileLocation.Trim().EndsWith("\"))
                    this.FileLocation = this.FileLocation.Trim() + "\"
            end

            ;;Make sure the output file location exists
            if (!directoryExists(this.FileLocation))
            begin
                mErrorMessage = "Destination folder " + mFileLocation + " does not exist!"
                mreturn false
            end

            ;;Define the output file name
            attempts = 0
            repeat
            begin
                ;;Construct the file name
                if (^passed(aPartialFileName) && (aPartialFileName.Trim().Length > 0)) then
                    this.FileName = DateTimeTools.GetTempFilePrefix() + " " + aPartialFileName.Trim() + ".pdf"
                else
                    this.FileName = DateTimeTools.GetTempFilePrefix() + ".pdf"

                ;;Make sure the file doesn't already exist
                if (fileExists(this.FileLocation + this.FileName)) then
                begin
                    if ((attempts+=1)>5)
                    begin
                        this.ErrorMessage = "Failed to construct unique output file name!"
                        mreturn false
                    end
                    sleep 0.1
                end
                else
                    exitloop
            end

            ;;Are we going to center the body at the requested with within the
            ;;page by manipulating the left and right margins
            if (^passed(aCenterBodyInPage)) then
                this.CenterBodyInPage = aCenterBodyInPage
            else
                this.CenterBodyInPage = true

            ;;Save the number of requested minimum columns
            if (^passed(aMinimumColumns) && aMinimumColumns) then
                this.RequestedColumns = aMinimumColumns
            else
                this.RequestedColumns = 80

            ok = false

            if (this.Columns < this.RequestedColumns) then
            begin
                ;;Not enough columns, decrease the font size until we get a match
                data newFontSize, int
                for newFontSize from mFontSize-1 thru 6 by -1
                begin
                    FontSize = newFontSize
                    pg.SetFontAndSize(fontNormal,fontSizeFloat)
                    this.ColumnWidth = pg.TextWidth("W")
                    totalColsDefaultOrientation = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)
                    totalColsOtherOrientation = (int)%truncate((this.Height-leftOffset-rightOffset)/this.ColumnWidth)
                    this.Columns = totalColsDefaultOrientation
                    if (this.Columns >= this.RequestedColumns)
                    begin
                        ok = true
                        exitloop
                    end
                end
            end
            else if (this.Columns > this.RequestedColumns) then
            begin
                ;;Too many columns, increase the font size until we have gone too far
                data newFontSize, int
                for newFontSize from mFontSize+1 thru 64
                begin
                    FontSize = newFontSize
                    pg.SetFontAndSize(fontNormal,fontSizeFloat)
                    this.ColumnWidth = pg.TextWidth("W")
                    totalColsDefaultOrientation = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)
                    totalColsOtherOrientation = (int)%truncate((this.Height-leftOffset-rightOffset)/this.ColumnWidth)
                    this.Columns = totalColsDefaultOrientation
                    if (this.Columns < this.RequestedColumns)
                    begin
                        ;;We went too far so back off to the previous font size
                        FontSize = mFontSize - 1
                        pg.SetFontAndSize(fontNormal,fontSizeFloat)
                        this.ColumnWidth = pg.TextWidth("W")
                        totalColsDefaultOrientation = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)
                        totalColsOtherOrientation = (int)%truncate((this.Height-leftOffset-rightOffset)/this.ColumnWidth)
                        this.Columns = totalColsDefaultOrientation
                        ok = true
                        exitloop
                    end
                end
            end
            else if (this.Columns == this.RequestedColumns)
            begin
                ;;Perfect match!
                ok = true
            end

            ;;If we were able to find a font size that provides the width that we need then we can continue
            if (ok) then
            begin
                ;;Were we given a maximum font size?
                if (^passed(aMaxFontSize) && aMaxFontSize)
                begin
                    if (this.FontSize > aMaxFontSize)
                    begin
                        ;;Selected font is bigger than maximum requested. Reduce to the requested size.
                        this.FontSize = aMaxFontSize
                        pg.SetFontAndSize(fontNormal,fontSizeFloat)
                        this.ColumnWidth = pg.TextWidth("W")
                        totalColsDefaultOrientation = (int)%truncate((this.Width-leftOffset-rightOffset)/this.ColumnWidth)
                        totalColsOtherOrientation = (int)%truncate((this.Height-leftOffset-rightOffset)/this.ColumnWidth)
                        this.Columns = totalColsDefaultOrientation
                    end
                end

                ;;How many rows fit on the page at the selected font size?
                this.RowHeight = fontSizeFloat

                totalRowsDefaultOrientation = %truncate((this.Height-topOffset-bottomOffset)/this.RowHeight)
                totalRowsOtherOrientation = %truncate((this.Width-topOffset-bottomOffset)/this.RowHeight)

                this.Rows = totalRowsDefaultOrientation - this.HeaderRows - this.FooterRows

                ;;If the page is wider than requested, should we manipulate the margins so that the
                ;;requested width is centered horizontally within the page?

                if ((this.Columns != this.RequestedColumns) && this.CenterBodyInPage)
                begin
                    data additionalColumns, int, this.Columns - this.RequestedColumns
                    data additionalPixels, int, additionalColumns * this.ColumnWidth

                    ;;Divide the additional space between the left and right margins
                    leftOffset += (additionalPixels / 2.0)
                    rightOffset += (additionalPixels / 2.0)

                    this.LeftMargin = leftOffset / 72.0
                    this.RightMargin = rightOffset / 72.0

                    totalColsDefaultOrientation = this.RequestedColumns
                    totalColsOtherOrientation = (int)%truncate((this.Height-leftOffset-rightOffset)/this.ColumnWidth)
                    this.Columns = totalColsDefaultOrientation
                end

                ;;Record where we're at
                this.PageNumber = 1
                this.Row = 1
                this.Column = 1

                ;;Add any begin page auto items
                if (this.AutoItems.Count > 0)
                begin
                    this.pageIsNew = false
                    this.printBeginPageItems()
                end

            end
            else
            begin
                this.ErrorMessage = "Failed to select a font size to produce the requested results!"
                Dispose()
            end

            mreturn ok

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Loads a TrueType font and embeds it in the PDF document ready for use.
        ;;; </summary>
        ;;; <param name="aFontFile">Full path to the font file (.ttf)</param>
        ;;; <returns>Returns the name of the font that can be passed to the SelectFont method.</returns>
        public method LoadTrueTypeFont, string
            required in aFontFile,      string
            endparams
            record
                ok, boolean
                fileSpec, string
                fontName, string
            endrecord
        proc
            ok = true
            fontName = ^null

            fileSpec = aFontFile.ToLower()
            if (!fileExists(fileSpec) || !fileSpec.EndsWith(".ttf"))
                ok = false

            if (ok)
                fontName = doc.LoadTTFontFromFile(fileSpec,true)

            mreturn fontName

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Sets the current position to the beginning of the next line. If the next line
        ;;; is outside of the page body then a new page is generated.
        ;;; </summary>
        ;;; <returns>Returns the new current row number.</returns>
        public method NewLine, int
            endparams
        proc
            if (this.Row < this.Rows) then
            begin
                this.Row = this.Row + 1
                this.Column = 1
            end
            else
            begin
                NewPage()
                printBeginPageItems()
            end

            mreturn this.Row

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Starts a new page.
        ;;; </summary>
        ;;; <returns>Returns the new page number.</returns>
        public method NewPage, int
            optional in aOrientation, PdfOrientation
            endparams
            record
                orientation, PdfOrientation
            endrecord
        proc

            ;;Print page level items on the current page
            printEndPageItems()

            ;;Default to the document default arientation
            orientation = this.DefaultOrientation

            ;;Determine the page orientation of the new page
            if (^passed(aOrientation) && (this.Orientation!=aOrientation)) then
            begin
                orientation = aOrientation
                if (this.Orientation == this.DefaultOrientation) then
                begin
                    this.Height = totalHeightOtherOrientation
                    this.Width = totalWidthOtherOrientation
                    this.Rows = totalRowsOtherOrientation - this.HeaderRows - this.FooterRows
                    this.Columns = totalColsOtherOrientation
                end
                else
                begin
                    this.Height = totalHeightDefaultOrientation
                    this.Width = totalWidthDefaultOrientation
                    this.Rows = totalRowsDefaultOrientation - this.HeaderRows - this.FooterRows
                    this.Columns = totalColsDefaultOrientation
                end
            end
            else
            begin
                if (this.Orientation != this.DefaultOrientation)
                begin
                    this.Height = totalHeightDefaultOrientation
                    this.Width = totalWidthDefaultOrientation
                    this.Rows = totalRowsDefaultOrientation - this.HeaderRows - this.FooterRows
                    this.Columns = totalColsDefaultOrientation
                end
            end

            ;;Add a new page to the PDF file
            pg = doc.AddPage((HPdfPageSizes)this.PageSize,(HPdfPageDirection)orientation)
            this.Orientation = orientation

            ;;Activate the font for the new page
            pg.StartPageWithFont(fontNormal,fontSizeFloat)
            pg.EndText()

            ;;Make sure that text is drawn as solid letters, not an outline with a seperate fill
            pg.SetTextRenderingMode(HPdfTextRenderingMode.HPDF_FILL)

            ;;Set any custom page background color
            setPageBackroundColor()

            ;;Put the default colors in place for the new page
            pg.SetRGBFill(textRed,textGreen,textBlue)
            pg.SetRGBStroke(lineRed,lineGreen,lineBlue)

            ;;Record the new page number and reset the page's current row counter
            this.PageNumber = this.PageNumber + 1
            this.Row = 1
            this.Column = 1

            pageIsNew = true

            mreturn this.PageNumber

        endmethod

.ifdef D_GUI
        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Displays the PDF file using the default application that is registered to handle
        ;;; PDF files. The Dispose method is automatically called so after calling this method
        ;;; the PdfFile object is no longer valid.
        ;;; </summary>
        ;;; <returns>Returns true if the PDF file was saved and launched.</returns>
        public method Preview, boolean
            endparams
        proc
            if (Save()) then
            begin
                ;;And launch the associated application
                xcall shell(,'"'+this.FileLocation+this.FileName+'"',D_NOCONSOLE|D_NOWAIT)
            end
            else
            begin
                ;;Error message already set by Save()
                mreturn false
            end

            mreturn true

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Print the PDF file to a printer.
        ;;; </summary>
        ;;; <param name="aPrinterName">Optional printer name</param>
        ;;; <returns></returns>
        public method Print, boolean
            optional in aPrinterName, string
            endparams
            .define D_GSPRINT_EXE 'C:\Program Files\Ghostgum\gsview\gsprint.exe'
            record
                ok, boolean
                pdffile, string
                command, string
            endrecord
        proc
            if (!fileExists(D_GSPRINT_EXE))
                throw new ApplicationException("GSPRINT.EXE not found!")

            pdffile = this.FileLocation + this.FileName

            if (Save()) then
            begin
                command = D_GSPRINT_EXE + ' -color -option "-q"'
                if (^passed(aPrinterName) && (aPrinterName.Trim().Length>0))
                    command = command + ' -printer "'+aPrinterName.Trim()+'"'
                command = command +  ' "' + pdffile + '"'
                try
                begin
                    xcall spawn(command,D_NOCONSOLE|D_NOWINDOW)
                    ok = true
                end
                catch (ex)
                begin
                    ok = false
                end
                endtry
            end
            else
            begin
                ;;Error message already set by Save()
                ok = false
            end

            mreturn ok

        endmethod

.endc
        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Resets the font to Courier and the size to that calculated during Initialize.
        ;;; Call this method to return to fixed-pitch row/column mode after woking with
        ;;; other (generally variable-pitch) fonts.
        ;;; </summary>
        public method ResetFont, void
            endparams
        proc
            pg.SetFontAndSize(fontNormal,fontSizeFloat)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Saves the PDF file to disk.
        ;;; </summary>
        ;;; <returns>Returns true if the PDF file was successfully saved.</returns>
        public method Save, boolean
            endparams
        proc
            ;;Print page level items on the last page
            printEndPageItems()

            ;;Create the PDF file on disk
            try
            begin
                doc.SaveToFile(this.FileLocation+this.FileName)
            end
            catch (ex)
            begin
                this.ErrorMessage = "Failed to save file " + this.FileLocation+mFileName
                mreturn false
            end
            endtry

            ;;Clean up
            this.Dispose()

            mreturn true

        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Selects the font that will be used for subsequent text operations.
        ;;; </summary>
        ;;; <param name="aFontName">Font name as returned by LoadTrueTypeFont, or one of the native PDF font names (Courier, Courier-Bold, Courier-Oblique, Courier-BoldOblique, Helvetica, Helvetica-Bold, Helvetica-Oblique, Helvetica-BoldOblique, Times-Roman, Times-Bold, Times-Italic, Times-BoldItalic, Symbol, ZapfDingbats)</param>
        ;;; <param name="aFontSize">Point size to use.</param>
        public method SelectFont, void
            required in aFontName, string
            required in aFontSize, int
            endparams
            record
                fontSize, float
                newFont, @HPdfFont
            endrecord
        proc
            newFont = doc.GetFont(aFontName, ^null)
            pg.SetFontAndSize(newFont,fontSize = aFontSize)
        endmethod

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Sets the current position within the current page.
        ;;; </summary>
        ;;; <param name="aRow">Row position, between 1 and Rows.</param>
        ;;; <param name="aColumn">Column position, between 1 and Columns.</param>
        public method SetPosition, void
            optional in aRow, int
            optional in aColumn, int
            endparams
        proc
            if (^passed(aRow))
            begin
                if (aRow < 1) then
                    this.Row = 1
                else if (aRow > this.Rows) then
                    this.Row = this.Rows
                else
                    this.Row = aRow
            end

            if (^passed(aColumn))
            begin
                if (aColumn < 1) then
                    this.Column = 1
                else if (aColumn > this.Columns) then
                    this.Column = this.Columns
                else
                    this.Column = aColumn
            end

        endmethod

        ;;********************************************************************************
        ;;PUBLIC PROPERTIES

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the name of the author of the PDF document.
        ;;; </summary>
        public property Author, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_AUTHOR)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_AUTHOR,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mAutoItems, @ArrayList

        ;;; <summary>
        ;;; Gets or sets a collection of auto objects that are to be drawn on each page.
        ;;; </summary>
        public property AutoItems, @ArrayList
            method get
            proc
                mreturn mAutoItems
            endmethod
            method set
            proc
                mAutoItems = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mBottomMargin, float

        ;;; <summary>
        ;;; Gets the height of the bottom margin in inches. Page margins are determined by parameters that are passed to the constructor and once defined cannot be changed. Margins only affect row and column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property BottomMargin, float
            method get
            proc
                mreturn mBottomMargin
            endmethod
            private method set
            proc
                mBottomMargin = value
                bottomOffset = mBottomMargin * 72
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mCenterBodyInPage, boolean

        ;;; <summary>
        ;;; Gets whether the main page body (the printable area inside any specified margins) will be centered horizontally. The default value is true, and this can be overridden via a parameter passed to the Initialize method. When true, after an appropriate font size has been calculated in order to facilitate the required column width of the document, the left and right margins are altered in order to ensure than content is centered horizontally within each page. Page margins and body only affect row / column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property CenterBodyInPage, int
            method get
            proc
                mreturn mCenterBodyInPage
            endmethod
            private method set
            proc
                mCenterBodyInPage = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mColumn, int

        ;;; <summary>
        ;;; Gets or sets the current column number. The concept of a current row and column is used when accessing the document by row and column, and is similar to the concept of current cursor position on the screen of a character based application. Generally, when displaying text to the document via the various methods that address row and column, the current position in the document moves either immediately after the printed text, or to the first column of the next row. Current row and column do not affect absolute positioning access to the document.
        ;;; </summary>
        public property Column, int
            method get
            proc
                mreturn mColumn
            endmethod
            method set
            proc
                mColumn = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mColumns, int

        ;;; <summary>
        ;;; Gets the number of columns that are available, based on the requested margins and page width, at the selected font size. The number of columns actually available will generally to be equal to or greater to the number of columns requested via the optional "minimum columns" parameter passed to the Initialize method. The number of available columns is only applicable when accessing the document by row and column, and does not affect absolute positioning access to the document.
        ;;; </summary>
        public property Columns, int
            method get
            proc
                mreturn mColumns
            endmethod
            private method set
            proc
                mColumns = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mColumnWidth, float

        ;;; <summary>
        ;;; Gets the width of a single column in device independent pixels (1/72 inch). The width is based on the font that was selected in order to achieve the number of columns required for the page. Column width is only applicable to row/column based access to the document using the default Courier font and has no significance when addressing the document via absolute positioning or alternate fonts.
        ;;; </summary>
        public property ColumnWidth, float
            method get
            proc
                mreturn mColumnWidth
            endmethod
            private method set
            proc
                mColumnWidth = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets the creation date of the document.
        ;;; </summary>
        public property CreationDate, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_CREATION_DATE)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the name of the creator of the PDF document. By default this property is set to "Synergex PSG PdfFile Class".
        ;;; </summary>
        public property Creator, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_CREATOR)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_CREATOR,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mDefaultOrientation, PdfOrientation

        ;;; <summary>
        ;;; Gets the default page orientation (portrait or landscape) of the PDF document. The deafult page orientation is defined for the document when calling the constructor method and cannot be changed.
        ;;; </summary>
        public property DefaultOrientation, PdfOrientation
            method get
            proc
                mreturn mDefaultOrientation
            endmethod
            private method set
            proc
                mDefaultOrientation = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mErrorMessage, string

        ;;; <summary>
        ;;; Gets the last error message. This property is populated by the methods that return a boolean (success) status. If a method returns a false status then the ErrorMessage property will contain a description of the reason for the failure.
        ;;; </summary>
        public property ErrorMessage, string
            method get
            proc
                mreturn mErrorMessage
            endmethod
            private method set
            proc
                mErrorMessage = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFileLocation, string

        ;;; <summary>
        ;;; Gets the location where the output file will be created as a full windows path including a trailing \.
        ;;; </summary>
        public property FileLocation, string
            method get
            proc
                mreturn mFileLocation
            endmethod
            private method set
            proc
                mFileLocation = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFileName, string

        ;;; <summary>
        ;;; Gets the name of the PDF file being created. The default name of the file will be in the format "YYYY-MM-DD HH.MM.SS <name> .pdf" where the value of <name> can be supplied via the optional "partial file name" parameter to the Initialize method. The name of the file is not used until you call either the Print, Preview or Save methods, so you may update the value of the property in order to override the default name until that time.
        ;;; </summary>
        public property FileName, string
            method get
            proc
                mreturn mFileName
            endmethod
            private method set
            proc
                mFileName = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFillColor, PdfColor
        private textRed,    float
        private textGreen,  float
        private textBlue,   float

        ;;; <summary>
        ;;; Gets or sets the current fill color, which is the colur used to paint the internal areas of both text and lines, and boxes if the optional "fill" parameter is passed and true. The default fill color is black. The default fill color can be overridden when printing or drawing individual text, line or box items.
        ;;; </summary>
        public property FillColor, PdfColor
            method get
            proc
                mreturn mFillColor
            endmethod
            method set
            proc
                mFillColor = value
                rgbFromPdfColor(mFillColor,textRed,textGreen,textBlue)
                pg.SetRGBFill(textRed,textGreen,textBlue)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFontSize, int
        private fontSizeFloat, float

        ;;; <summary>
        ;;; Gets the height of the default (automatically selected) font in device independent pixels (1/72 inch). The FontSize only has relevance when addressing the document using the default (Coruier) font.
        ;;; </summary>
        public property FontSize, int
            method get
            proc
                mreturn mFontSize
            endmethod
            private method set
            proc
                mFontSize = value
                fontSizeFloat = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFooterRows, int

        ;;; <summary>
        ;;; Gets the number of footer rows that were reserved when the document was created. Footer rows are only relevant when using the FooterText property, and have no affect when accessing the document via absolute positioning mechanisms.
        ;;; </summary>
        public property FooterRows, int
            method get
            proc
                mreturn mFooterRows
            endmethod
            private method set
            proc
                mFooterRows = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFooterText, [#]string

        ;;; <summary>
        ;;; Gets or sets the array of strings to be displayed in the reserved page footer rows of pages that use the default page orientation. The array is initialized based on the number of footer rows requested when calling the constructor, and can subsequently be populated with the data to be displayed in the reserved footer area of each page.
        ;;; </summary>
        public property FooterText, [#]string
            method get
            proc
                mreturn mFooterText
            endmethod
            private method set
            proc
                mFooterText = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mFooterTextAlternate, [#]string

        ;;; <summary>
        ;;; Gets or sets the array of strings to be displayed in the reserved page footer rows of pages with the alternate orientation. The array is initialized based on the number of footer rows requested when calling the constructor, and can subsequently be populated with the data to be displayed in the reserved footer area of each page.
        ;;; </summary>
        public property FooterTextAlternate, [#]string
            method get
            proc
                mreturn mFooterTextAlternate
            endmethod
            private method set
            proc
                mFooterTextAlternate = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mHeaderRows, int

        ;;; <summary>
        ;;; Gets the number of header rows that were reserved when the document was created. Header rows are only relevant when using the FooterText property, and have no affect when accessing the document via absolute positioning mechanisms.
        ;;; </summary>
        public property HeaderRows, int
            method get
            proc
                mreturn mHeaderRows
            endmethod
            private method set
            proc
                mHeaderRows = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mHeaderText, [#]string

        ;;; <summary>
        ;;; Gets or sets the array of strings to be displayed in the reserved page header rows of pages that use the default page orientation. The array is initialized based on the number of header rows requested when calling the constructor, and can subsequently be populated with the data to be displayed in the reserved header area of each page.
        ;;; </summary>
        public property HeaderText, [#]string
            method get
            proc
                mreturn mHeaderText
            endmethod
            private method set
            proc
                mHeaderText = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mHeaderTextAlternate, [#]string

        ;;; <summary>
        ;;; Gets or sets the array of strings to be displayed in the reserved page header rows. The array is initialized based on the number of header rows requested when calling the constructor, and can subsequently be populated with the data to be displayed in the reserved header area of each page.
        ;;; </summary>
        public property HeaderTextAlternate, [#]string
            method get
            proc
                mreturn mHeaderTextAlternate
            endmethod
            private method set
            proc
                mHeaderTextAlternate = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mHeight, float

        ;;; <summary>
        ;;; Gets the height of the page in device independent pixels (1/72 inch). The height of the page is based on the paper size and orientation and defines the maximum value for Y coordinates when addressing the document via absolute positioning mechanisms.
        ;;; </summary>
        public property Height, float
            method get
            proc
                mreturn mHeight
            endmethod
            private method set
            proc
                mHeight = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the keywords of the PDF document.
        ;;; </summary>
        public property Keywords, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_KEYWORDS)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_KEYWORDS,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mLeftMargin, float

        ;;; <summary>
        ;;; Gets the width of the left margin in inches. Page margins are determined by parameters that are passed to the constructor and once defined cannot be changed. Margins only affect row and column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property LeftMargin, float
            method get
            proc
                mreturn mLeftMargin
            endmethod
            private method set
            proc
                mLeftMargin = value
                leftOffset = mLeftMargin * 72
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets the modification date attribute of the PDF document.
        ;;; </summary>
        public property ModificationDate, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_MOD_DATE)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mOrientation, PdfOrientation

        ;;; <summary>
        ;;; Gets the page orientation (portrait or landscape) of the current page. The page orientation is defined when a new page is added to the document.
        ;;; </summary>
        public property Orientation, PdfOrientation
            method get
            proc
                mreturn mOrientation
            endmethod
            private method set
            proc
                mOrientation = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mPageBackgroundColor,   PdfColor
        private pageBackgroundRed,  float
        private pageBackgroundGreen,    float
        private pageBackgroundBlue, float

        ;;; <summary>
        ;;; Gets or sets the page background color. A custom value for page background color can be established via an optional parameter passed to the constructor method, and will be used for the first page. Subsequently changing the page background color will affect only new pages that are created after the background color is changed. There is no way to change the background color of a page after the page has been created. The default page background color is white.
        ;;; </summary>
        public property PageBackgroundColor, PdfColor
            method get
            proc
                mreturn mPageBackgroundColor
            endmethod
            method set
            proc
                mPageBackgroundColor = value
                rgbFromPdfColor(mPageBackgroundColor,pageBackgroundRed,pageBackgroundGreen,pageBackgroundBlue)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mPageNumber, int

        ;;; <summary>
        ;;; Gets the current page number. New pages can be created implicitly if performing "sequential writes" to the document, or explicitly by calling the the NewPage method. Once the document advances to a new page there is no way to go back to address earlier pages.
        ;;; </summary>
        public property PageNumber, int
            method get
            proc
                mreturn mPageNumber
            endmethod
            private method set
            proc
                mPageNumber = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mPageSize, PdfPageSize

        ;;; <summary>
        ;;; Gets the page size used within the document.
        ;;; </summary>
        public property PageSize, PdfPageSize
            method get
            proc
                mreturn mPageSize
            endmethod
            private method set
            proc
                mPageSize = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRequestedColumns, int

        ;;; <summary>
        ;;; Number of columns originally requested by the consuler.
        ;;; </summary>
        public property RequestedColumns, int
            method get
            proc
                mreturn mRequestedColumns
            endmethod
            private method set
            proc
                mRequestedColumns = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRightMargin, float

        ;;; <summary>
        ;;; Gets the width of the right margin in inches. Page margins are determined by parameters that are passed to the constructor and once defined cannot be changed. Margins only affect row and column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property RightMargin, float
            method get
            proc
                mreturn mRightMargin
            endmethod
            private method set
            proc
                mRightMargin = value
                rightOffset = mRightMargin * 72
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRow, int

        ;;; <summary>
        ;;; Gets or sets the current row number. The concept of a current row and column is used when accessing the document by row and column, and is similar to the concept of current cursor position on the screen of a character based application. Generally, when displaying text to the document via the various methods that address row and column, the current position in the document moves either immediately after the printed text, or to the first column of the next row. Current row and column do not affect absolute positioning access to the document.
        ;;; </summary>
        public property Row, int
            method get
            proc
                mreturn mRow
            endmethod
            method set
            proc
                mRow = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRowHeight, float

        ;;; <summary>
        ;;; Height of a row in device independent pixels (1/72 inch).
        ;;; </summary>
        public property RowHeight, float
            method get
            proc
                mreturn mRowHeight
            endmethod
            private method set
            proc
                mRowHeight = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mRows, int

        ;;; <summary>
        ;;; Gets the number of rows that are available within the page body (i.e. between any top margin, header rows, footer rows and bottom margin), based on the page height, the requested top and bottom margins, and the number and height of any page header and footer rows, at the selected font size. The number of available rows is only applicable when accessing the document by row and column mechanisms and has no effect when accessing to the document via absolute positioning mechanisms.
        ;;; </summary>
        public property Rows, int
            method get
            proc
                mreturn mRows
            endmethod
            private method set
            proc
                mRows = value
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mStrokeColor,   PdfColor
        private lineRed,    float
        private lineGreen,  float
        private lineBlue,   float

        ;;; <summary>
        ;;; Gets or sets the current stroke color, which is the color used to paint the outside edge of lines, boxes and text. The default stroke color is black. The default stroke color can be overridden when printing or drawing individual text, line or box items.
        ;;; </summary>
        public property StrokeColor, PdfColor
            method get
            proc
                mreturn mStrokeColor
            endmethod
            method set
            proc
                mStrokeColor = value
                rgbFromPdfColor(mStrokeColor,lineRed,lineGreen,lineBlue)
                pg.SetRGBStroke(lineRed,lineGreen,lineBlue)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the subject attribute of the PDF document.
        ;;; </summary>
        public property Subject, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_SUBJECT)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_SUBJECT,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;; <summary>
        ;;; Gets or sets the title attribute of the PDF document.
        ;;; </summary>
        public property Title, string
            method get
            proc
                mreturn doc.GetInfoAttr(HPdfInfoType.HPDF_INFO_TITLE)
            endmethod
            method set
            proc
                doc.SetInfoAttr(HPdfInfoType.HPDF_INFO_TITLE,value)
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mTopMargin, float

        ;;; <summary>
        ;;; Gets the height of the top margin in inches. Page margins are determined by parameters that are passed to the constructor and once defined cannot be changed. Margins only affect row and column based access to the document and do not affect absolute positioning access.
        ;;; </summary>
        public property TopMargin, float
            method get
            proc
                mreturn mTopMargin
            endmethod
            private method set
            proc
                mTopMargin = value
                topOffset = mTopMargin * 72
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mUseAlternateFooters, boolean, false

        ;;; <summary>
        ;;; Gets or sets whether alternate text should be displayed in the page footers of pages that use the opposite orientation to the document default orientation. The default is that the same footer text is used for all pages. If this property is set to true then the alternative footer text should then be specified via the FooterTextAlternate property.
        ;;; </summary>
        public property UseAlternateFooters, boolean
            method get
            proc
                mreturn mUseAlternateFooters
            endmethod
            method set
            proc
                ;;We can only enable this if there are footer rows
                if (this.FooterRows > 0) then
                    mUseAlternateFooters = value
                else
                    mUseAlternateFooters = false

                ;;Initialize the array of alternate footer items
                if (mUseAlternateFooters) then
                begin
                    data ix, int
                    this.FooterTextAlternate = new string[this.FooterRows]
                    for ix from 1 thru this.FooterRows
                        this.FooterTextAlternate[ix] = ""
                end
                else
                    this.FooterTextAlternate = ^null
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mUseAlternateHeaders, boolean, false

        ;;; <summary>
        ;;; Gets or sets whether alternate text should be displayed in the page headers of pages that use the opposite orientation to the document default orientation. The default is that the same header text is used for all pages. If this property is set to true then the alternative headter text should then be specified via the HeaderTextAlternate property.
        ;;; </summary>
        public property UseAlternateHeaders, boolean
            method get
            proc
                mreturn mUseAlternateHeaders
            endmethod
            method set
            proc
                ;;We can only enable this if there are header rows
                if (this.HeaderRows > 0) then
                    mUseAlternateHeaders = value
                else
                    mUseAlternateHeaders = false

                ;;Initialize the array of alternate header items
                if (mUseAlternateHeaders) then
                begin
                    data ix, int
                    this.HeaderTextAlternate = new string[this.HeaderRows]
                    for ix from 1 thru this.HeaderRows
                        this.HeaderTextAlternate[ix] = ""
                end
                else
                    this.HeaderTextAlternate = ^null
            endmethod
        endproperty

        ;;--------------------------------------------------------------------------------
        ;;

        private mWidth, float

        ;;; <summary>
        ;;; Gets the width of the page in device independent pixels (1/72 inch). The width of the page is based on the paper size and orientation and defines the maximum value for X coordinates when addressing the document via absolute positioning mechanisms.
        ;;; </summary>
        public property Width, float
            method get
            proc
                mreturn mWidth
            endmethod
            private method set
            proc
                mWidth = value
            endmethod
        endproperty

    endclass

endnamespace

