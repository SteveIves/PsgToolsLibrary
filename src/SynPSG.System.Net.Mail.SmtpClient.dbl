;;**********************************************************************
;;
;; Title:       SmtpClient.dbc
;;
;; Type:        Class
;;
;; Description:	Communictates with an SMTP server in order to send email
;;
;; IMPORTANT:   Just lie the underlying .NET Framework class, this class
;;              supports using the "SMTP Service Extension for Secure SMTP
;;              over Transport Layer Security" as defined in RFC 3207.
;;              In this mode, the SMTP session begins on an unencrypted
;;              channel, then a STARTTLS command is issued by the client
;;              to the server to switch to secure communication using SSL.
;;              See RFC 3207 published by the Internet Engineering Task
;;              Force (IETF) for more information.”
;;
;;      	Problem is this is NOT the type of SSL that is used by
;;              many ISPs, who frequently use an alternate connection
;;              method is where an SSL session is established up front
;;              before any protocol commands are sent. This connection
;;              method is sometimes called SMTP/SSL, SMTP over SSL, or
;;              SMTPS and by default uses port 465. This alternate
;;              connection method using SSL is not currently supported.
;;
;; Author:      Tod Phillips, Synergex Professional Services Group
;;
;; Copyright    © 2009 Synergex International Corporation.  All rights reserved.
;;
;; WARNING:     All content constituting or related to this code ("Code") is the
;;              property of Synergex International Corporation ("Synergex") and
;;              is protected by U.S. and international copyright laws.
;;              If you were given this Code by a Synergex employee then you may
;;              use and modify it freely for use within your applications.
;;
;;              However, you may use the Code only for your personal use.
;;              Any other use, unless otherwise authorized in writing by
;;              Synergex is strictly prohibited.  You may not under any
;;              circumstances distribute this Code, or any modified version
;;              or part of this Code, to any third party without first
;;              obtaining written permission to do so from Synergex.
;;              In using this Code you accept that it is provided as is,
;;              and without support or warranty of any kind.
;;
;;              Neither Synergex nor the author accept any responsibility
;;              for any losses or damages of any nature which may arise
;;              from the use of this Code.  This header information must
;;              remain unaltered in the Code at all times.  Possession
;;              of this Code, or any modified version or part of this Code,
;;              indicates your acceptance of these terms.
;;
;;***********************************************************************************

.ifndef DBLNET

import SynPSG.System
import SynPSG.System.IO
import SynPSG.System.Net
import SynPSG.System.Net.Mail
import SynPSG.System.Net.Mime
import SynPSG.System.Net.Sockets
import SynPSG.System.Text.encoding
import System.Collections

.include "DBLDIR:synsock.def"

.define CRLF    %char(13)+%char(10)
.define CR      %char(13)
.define LF      %char(10)

namespace SynPSG.System.Net.Mail

    public class SmtpClient
        private mHost      ,string
        private mPort      ,integer
        private mRespCode  ,integer
        private mRespContinuation  ,boolean
        private mRespStr   ,string
        private mByte      ,i1
        private mErrMsg    ,string
        private mTcpClient ,@TcpClient
        private mNStream   ,@NetworkStream
        private mCredentials,@NetworkCredential

        ;;;<summary>
        ;;;Initializes a new instance of the SmtpClient class that sends e-mail by using the specified SMTP server.
        ;;;</summary>
        public method SmtpClient
            in host     ,string
        proc
            if ((host==^null) || (host.length==0)) then
                mHost = "localhost"
            else
                mHost = host
            mPort = 25
        endmethod

        ;;;<summary>
        ;;;Initializes a new instance of the SmtpClient class that sends e-mail by using the specified SMTP server and port.
        ;;;</summary>
        public method SmtpClient
            in host     ,string
            in port     ,integer
        proc
            if ((host==^null) || (host.length==0)) then
                mHost = "localhost"
            else
                mHost = host
            if (port <= 0) then
                mPort = 25
            else
                mPort = port
        endmethod

        ;;;<summary>
        ;;;</summary>
        public property Host, string
            method get
            proc
                mreturn mHost
            endmethod
            method set
            proc
                mHost = value
            endmethod
        endproperty

        ;;;<summary>
        ;;;</summary>
        public property Port, integer
            method get
            proc
                mreturn mPort
            endmethod
            method set
            proc
                mPort = value
            endmethod
        endproperty

        ;;;<summary>
        ;;;</summary>
        public property Credentials ,@NetworkCredential
            method get
            proc
                mreturn mCredentials
            endmethod
            method set
            proc
                mCredentials = value
            endmethod
		endproperty

		;;; <summary>
		;;; Sends a QUIT message to the SMTP server, gracefully ends the TCP connection, and releases all resources used by the current instance of the SmtpClient class.
		;;; </summary>
		public method Dispose	,void
			endparams
			stack record
				buff	,string
			endrecord
		proc
			if (mNStream != ^null)	;; if the stream is there, send a quit message
			begin
				buff = "QUIT"+CRLF
				mNStream.Write(buff,0,buff.Length)
				getSmtpLine()
				CheckResponseCode(221)
				mNStream.Close()
			end
			if (mTcpClient != ^null)
				mTcpClient.Close()
		endmethod

        ;;;<summary>
        ;;;Sends an e-mail message to an SMTP server for delivery using the supplied MailMessage object.
        ;;;</summary>
        public method Send  ,void
            in message      ,@MailMessage
            endparams

			structure block
				,a32768
			endstructure

			record
				ctr             ,i4             ;; general purpose loop counter
				group dt
					year        ,a4
					month       ,d2
					day         ,a2
					hour        ,a2
					minute      ,a2
					seconds     ,a2
					milli       ,a6
				endgroup
				m_data          ,a28500         ;; Equates to 500 SMTP lines (57 bytes before conversion to Base64, 76 bytes + CRLF after conversion)
				m_data_len      ,i4             ;; number of characters in m_data
				minsOffset      ,i4             ;; timezone offset (in minutes)
				UMToffset       ,a5             ;; string representation of timezone offset
			endrecord

			record
				buff            ,string
				m_senderHost    ,string
				m_senderAddress ,string
				m_tempAddress   ,@MailAddress
			endrecord
			
        proc

			;;Enable debug logging if requested
			startDebugLog()
			
            if (message.From.Address == "")
                throw new applicationexception("No from address provided.")

            if (message.To.Count == 0)
                throw new applicationexception("No to addresses specified.")

;            if (message.Sender!=^null && message.Sender.Address.Length>0 && message.Sender.Address!=message.From.Address) then
;            begin
;                m_senderHost = message.Sender.Host
;                m_senderAddress = message.Sender.Address
;            end
;            else
;            begin
                m_senderHost = message.From.Host
                m_senderAddress = message.From.Address
;            end

			debugLog("Creating TcpClient to host "+mHost.Trim()+" port "+%string(mPort))
            mTcpClient = new TcpClient(mHost, mPort)
            mNStream = mTcpClient.GetStream()

            ;;Set the timeout to 30 seconds
            mNStream.ReadTimeout = 30000

            ;;Get initial response from the server
			begin
				data tempBuf    ,a1024
				data len, i4
				if (len=mNStream.Read(tempBuf,0,^size(tempBuf)))
				begin
					mRespCode = %integer(tempBuf(1:3))
					mRespContinuation = false
					mRespStr = tempBuf(5,len)
					debugLog("Recv: "+%string(mRespCode,"XXX")+" "+mRespStr)
				end
				CheckResponseCode(220)
			end

            ;;Service is available
			;;Tell the server the sender's domain
            mRespStr = mRespStr.ToUpper()

            ;;If "ESMTP" was in the previous 220 response then the server should support EHLO
			;;Send the HELO or EHLO message
            if(mRespStr.Contains("ESMTP")) then
                buff = "EHLO "+m_senderHost
            else
                buff = "HELO "+m_senderHost
			sendMessage(buff,true)
            getSmtpLine()
            CheckResponseCode(220)

            ;;Get any additional responses after logon
            while(mRespContinuation==true)
            begin
                getSmtpLine()
                CheckResponseCode(250)
            end

            if(mRespStr.StartsWith("TLS "))
            begin
                buff = "STARTTLS TLS1.0"
				sendMessage(buff,true)
                getSmtpLine()
                CheckResponseCode(220)

                buff = "EHLO "+m_senderHost
				sendMessage(buff,true)
                getSmtpLine()
                CheckResponseCode(220)

                ;; get additional responses after logon
                while(mRespContinuation==true)
                begin
                    getSmtpLine()
                    CheckResponseCode(250)
                end
            end

            if(mRespStr.StartsWith("AUTH "))
            begin
                ;; performed authentication
                data authenticated ,boolean ,false

                if (mRespStr.Contains(" LOGON "))
                begin
                    buff = "auth login"
					sendMessage(buff,true)

                    ;; get username prompt
                    getSmtpLine()
                    checkResponseCode(334)

                    ;; base64 encrypted username
                    buff = Convert.ToBase64String(AsciiEncoding.GetBytes(Credentials.Username),SynPSG.Base64FormattingOptions.None)
					sendMessage(buff,true)

                    ;; get password prompt
                    getSmtpLine()
                    checkResponseCode(334)

                    ;; base64 encrypted password
                    buff = Convert.ToBase64String(AsciiEncoding.GetBytes(Credentials.Password),SynPSG.Base64FormattingOptions.None)
					sendMessage(buff,true)

                    authenticated = true
                end

                if (authenticated == false && mRespStr.Contains(' PLAIN '))
                begin
                    buff = "AUTH PLAIN"
					sendMessage(buff,true)

                    ;; get empty response
                    getSmtpLine()
                    checkResponseCode(334)

                    ;base64 encrypted simple username
                    buff = Convert.ToBase64String(AsciiEncoding.GetBytes(Credentials.Username),SynPSG.Base64FormattingOptions.None)
					sendMessage(buff,true)

                    authenticated = true
                end

                if (authenticated == false && mRespStr.Contains(' CRAM-MD5 '))
                begin
					debugLog("Recv: "+%string(mRespCode,"XXX")+" "+mRespStr)
					buff = "Server requested usupported authentication mecanism: CRAM-MD5"
					debugLog("Fail: "+buff)
					throw new ApplicationException(buff)
                end

                if (authenticated == false && mRespStr.Contains(' DIGEST-MD5 '))
                begin
					debugLog("Recv: "+%string(mRespCode,"XXX")+" "+mRespStr)
					buff = "Server requested usupported authentication mecanism: DIGEST-MD5"
					debugLog("Fail: "+buff)
					throw new ApplicationException(buff)
                end

                if (authenticated == false && mRespStr.Contains(' GSSAPI '))
                begin
					debugLog("Recv: "+%string(mRespCode,"XXX")+" "+mRespStr)
					buff = "Server requested usupported authentication mecanism: GSSAPI"
					debugLog("Fail: "+buff)
					throw new ApplicationException(buff)
                end

                if(authenticated == false)
				begin
					debugLog("Recv: "+%string(mRespCode,"XXX")+" "+mRespStr)
					buff = "Unknown Authentication Request: " + mRespStr
					debugLog("Fail: "+buff)
                    throw new ApplicationException(buff)
				end

                ;; get authorization response
                getSmtpLine()
                checkResponseCode(235)
            end

            ;;Tell the server about the sender
            buff = "MAIL FROM:<"+m_senderAddress+">"
			sendMessage(buff,true)

            getSmtpLine()
            checkResponseCode(0)

            ;;Send recipient list
            for ctr from 1 thru message.To.Count
            begin
                buff = "RCPT TO:<"+message.To[ctr-1].Address+">"
				sendMessage(buff,true)
                getSmtpLine()

				;----------------------------------------------------------------------------------
				;;This code was added by Steve Ives because this behavior was seen in some
				;;SMTP servers requiring authentication (e.g. the Arvixe servers).
				if (mRespStr=="SMTP authentication is required.") ;530
				begin
					buff = "auth login"
					sendMessage(buff,true)

					;;get username prompt
					getSmtpLine()
					checkResponseCode(334)

					;;base64 encrypted username
					buff = Convert.ToBase64String(AsciiEncoding.GetBytes(Credentials.Username),SynPSG.Base64FormattingOptions.None)
					sendMessage(buff,true)

					;;get password prompt
					getSmtpLine()
					checkResponseCode(334)

					;;base64 encrypted password
					buff = Convert.ToBase64String(AsciiEncoding.GetBytes(Credentials.Password),SynPSG.Base64FormattingOptions.None)
					sendMessage(buff,true)

					getSmtpLine()
					checkResponseCode(235)	;Should be 235 "authenticated."

					;;Now we need to send the RCPT TO again because the last one
					;;wasn't processed because of the authentication request.
					buff = "RCPT TO:<"+message.To[ctr-1].Address+">"
					sendMessage(buff,true)
					getSmtpLine()
				end

				checkResponseCode(0)

            end

            ;;Send cc list
            for ctr from 1 thru message.CC.Count
            begin
                buff = "RCPT TO:<"+message.CC[ctr-1].Address+">"
				sendMessage(buff,true)

                getSmtpLine()
                checkResponseCode(0)
            end

            ;;Now send DATA command
			sendMessage("DATA",true)
            getSmtpLine()
            checkResponseCode(354)

            ;;Send message header
			sendMessage("X-Mailer: Synergy DBL",true)
			sendMessage(SynPSG.StringUtil.Format("Date: {0:ddd dd MMM yyyy HH:mm:ss zzz}", %datetime),true)

            ;;Sender
            if (message.From.DisplayName) then
				sendMessage('From: "'+message.From.DisplayName+'" <'+message.From.Address+'>',true)
            else
				sendMessage("From: "+message.From.Address,true)
			

            ;;Recipient
            buff = "To:"
            for ctr from 1 thru message.To.Count
            begin
                if (ctr>1)
                    buff = String.Concat(buff,',')
                if (message.To[ctr-1].DisplayName) then
                    buff = String.Concat(buff,' "'+message.To[ctr-1].DisplayName+'" <'+message.To[ctr-1].Address+'>')
                else
                    buff = String.Concat(buff,' '+message.To[ctr-1].Address)
            end
			sendMessage(buff,true)

            ;;CC:
            if (message.CC.Count>0)
            begin
                buff = "Cc:"
                for ctr from 1 thru message.CC.Count
                begin
                    if (ctr>1)
                        buff = String.Concat(buff,',')
                    if (message.CC[ctr-1].DisplayName) then
                        buff = String.Concat(buff,' "'+message.CC[ctr-1].DisplayName+'" <'+message.CC[ctr-1].Address+'>')
                    else
                        buff = String.Concat(buff," "+message.CC[ctr-1].Address)
				end
				sendMessage(buff,true)
            end

            ;;BCC:
            if (message.Bcc.Count>0)
            begin
                buff = "Bcc:"
                for ctr from 1 thru message.Bcc.Count
                begin
                    if (ctr>1)
                        buff = String.Concat(buff,',')
                    if (message.Bcc[ctr-1].DisplayName) then
                        buff = String.Concat(buff,' "'+message.Bcc[ctr-1].DisplayName+'" <'+message.Bcc[ctr-1].Address+'>')
                    else
                        buff = String.Concat(buff," "+message.Bcc[ctr-1].Address)
				end
				sendMessage(buff,true)
            end

            ;;Reply to
            if (message.ReplyTo!=^null)
            begin
                if (message.ReplyTo.DisplayName.Length>0) then
                    buff = 'Reply-To: "'+message.ReplyTo.DisplayName+'" <'+message.ReplyTo.Address+'>'
                else
                    buff = "Reply-To: "+message.ReplyTo.Address
				sendMessage(buff,true)
            end

            ;;Subject
			sendMessage("Subject: "+message.Subject,true)

            ;;Content MIME headers
			sendMessage("Mime-Version: 1.0",true)

            if (message.Attachments.Count>0) then
                buff = 'Content-Type: multipart/mixed; boundary="_NextPart_'+%hex(%jbno)+'"'
            else
                if (message.IsBodyHtml) then
                    buff = 'Content-Type: text/html; charset="iso-8859-1"'
                else
                    buff = 'Content-Type: text/plain; charset="iso-8859-1"'
			sendMessage(buff,true)

            ;;Attachments
            if (message.Attachments.Count>0)
            begin
				sendMessage("",true)
				sendMessage("--_NextPart_"+%hex(%jbno),true)
                if (message.IsBodyHtml) then
                    sendMessage('Content-Type: text/html; charset="iso-8859-1"',true)
                else
                    sendMessage('Content-Type: text/plain; charset="iso-8859-1"',true)
            end
            sendMessage("Content-Transfer-Encoding: quoted-printable",true)
			sendMessage("",true)

			;;Message body
            sendMessage(message.Body,true)
			
            for ctr from 1 thru message.Attachments.Count
            begin
				data atch, @Attachment, message.Attachments[ctr-1]

				sendMessage("",true)
                sendMessage("--_NextPart_"+%hex(%jbno),true)
                sendMessage("Content-Type: "+atch.ContentType.ToString(),true)
                sendMessage("Content-Disposition: "+atch.ContentDisposition.DispositionType+'; filename="'+atch.Name+'"',true)

                using atch.TransferEncoding select
                (TransferEncoding.Base64),
                    sendMessage('Content-Transfer-Encoding: base64',true)
                (TransferEncoding.QuotedPrintable),
                    sendMessage('Content-Transfer-Encoding: quoted-printable',true)
                (),
                    sendMessage('Content-Transfer-Encoding: 7bit',true)
                endusing

				sendMessage("",true)
				
                repeat
                begin
                    m_data_len = ((FileStream)atch.ContentStream).Read(m_data,0,^size(m_data))
                    ;; Check for EndOfFile condition
                    if (!m_data_len)
                        exitloop
                    using atch.TransferEncoding select
                    (TransferEncoding.Base64),
                        sendMessage(Convert.ToBase64String(AsciiEncoding.GetBytes(m_data(1:m_data_len)),SynPSG.Base64FormattingOptions.InsertLineBreaks),false)
                    (),
						sendMessage(m_data(1:m_data_len),false)
                    endusing
                    if (!m_data_len)
                        exitloop
                end
            end

            if (message.Attachments.Count>0)
				sendMessage('--_NextPart_'+%hex(%jbno)+"--",true)

			sendMessage(".",true)

            getSmtpLine()
            checkResponseCode(250)

			endDebugLog()
			
            mreturn

        endmethod
		
		private method sendMessage, void
			required in messageToSend, string
			required in addCrLf, boolean
			endparams
			record 
				msg, string
			endrecord
		proc
			debugLog("Send: "+messageToSend)
			msg = messageToSend
			if (addCrLf)
				msg = msg + CRLF
			mNStream.Write(msg,0,msg.Length)
		endmethod
		
		private mEnableLogging, boolean, false
		private mLoggingOn, boolean, false
		
		public property EnableLogging, boolean
			method get
			proc
				mreturn mEnableLogging
			endmethod
			method set
			proc
				mEnableLogging = value
			endmethod
		endproperty
		
		private debugLogChannel, i4

		private method startDebugLog, void
			endparams
		proc
			if (mEnableLogging&&(!mLoggingOn))
			begin
				open(debugLogChannel=0,o,"SmtpClient.log")
				mLoggingOn = true
			end
		endmethod
		
		private method endDebugLog, void
			endparams
		proc
			if (mLoggingOn)
			begin
				close debugLogChannel
				mLoggingOn = false
			end
		endmethod

		private method debugLog, void
			required in logMessage, string
			endparams
		proc
			if (mLoggingOn)
				writes(debugLogChannel,logMessage)
		endmethod

        ;;;<summary>
        ;;;Sends an e-mail message to an SMTP server for delivery using the supplied string arguments.
        ;;;</summary>
        public method Send, void
            in from     ,string
            in to       ,string
            in subject  ,string
            in body     ,string
            endparams
        proc
            this.Send(new MailMessage(from,to,subject,body))
        endmethod

        private method getSmtpLine, void
            endparams

			stack record vars
				lineBuf     ,a1024
				byteCount   ,i4
			endrecord

        proc
            init lineBuf,byteCount

            ;; Read one byte at a time from the stream, so that we can identify 
            ;; when a LineFeed has been passed
            while ((mByte=mNStream.ReadByte())!=(-1) && %char(mByte)!=LF)
                lineBuf(byteCount+=1:1)=%char(mByte)

            ;; remove trailing CR (if present)
            if(byteCount>0 && lineBuf(byteCount:1)==CR)
                byteCount -= 1

            try
            begin
                mRespCode = %integer(lineBuf(1:3))
                if(lineBuf(4:1)==' ') then
                    mRespContinuation = false
                else
                    mRespContinuation = true
                mRespStr = lineBuf(5,byteCount)
            end
            catch (ex)
            begin
                mRespCode = 999
                mRespContinuation = false
                if(byteCount>0) then
                    mRespStr = lineBuf(1,byteCount)
                else
                    mRespStr = ""
            end
            endtry

			debugLog("Recv: "+%string(mRespCode,"XXX")+" "+mRespStr)

        endmethod

        private method checkResponseCode,   void
            req in expectedResponseCode,	integer    ;; expected response
            endparams
        proc
            mErrMsg = ""

			;;Did we get the response we expected?
            if (expectedResponseCode && (mRespCode==expectedResponseCode))
                mreturn

			;;No. So what response did we get?
            using mRespCode select

            (100 thru 199),
                mreturn ;; ok preliminary reply

            (200 thru 299),
                mreturn ;; ok completion reply

            (300 thru 399),
                mreturn ;; ok intermeditate reply

            (421),
                if (mRespStr.Length>0) then
                    mErrMsg = mRespStr
                else
                    mErrMsg = "Domain Service not available."

            (450),
                mErrMsg = "Requested mail action not taken: mailbox unavailable."

            (451),
                mErrMsg = "Requested action aborted: local error in processing."

            (452),
                mErrMsg = "Requested action not taken: insufficient system storage."

            (500),
                mErrMsg = "Syntax error, command unrecognized."

            (501),
                mErrMsg = "Syntax error in paramaters or arguments."

            (502),
                mErrMsg = "Command not implemented."

            (503),
                mErrMsg = "Bad sequence of commands."

            (504),
                mErrMsg = "Command paramater not implemented."

            (521),
                if (mRespStr.Length>0) then
                    mErrMsg = mRespStr
                else
                    mErrMsg = "Domain does not accept mail."

            (530),
                mErrMsg = "Access denied."

			(535),
				mErrMsg = "Authentication credentials invalid."

            (550),
                mErrMsg = "Requested action not taken: mailbox unavailable."

            (551),
                if (mRespStr.Length>0) then
                    mErrMsg = mRespStr
                else
                    mErrMsg = "User not local."

            (552),
                mErrMsg = "Requested mail action aborted: exceeded storage allocation."

            (553),
                mErrMsg = "Requested action not taken: mailbox name not allowed."

            (554),
                mErrMsg = "Transaction failed."

            (560),
                mErrMsg = "Must issue STARTTLS command first."

            (),
                mErrMsg = "Unrecognized SMTP response "+%string(mRespCode)+". SmtpClient.checkResponseCode should be enhanced!"

            endusing

            if (mErrMsg.Length)
            begin
                ;mNStream.Close()
				;SI: I don't think we should close the stream, because the Dispose method attempts to send a quit message!
				;If we DO close the stream here then we should also do mNStream = ^null to prevent that

                throw new ApplicationException(mErrMsg)
            end

        endmethod

    endclass

endnamespace

.endc
